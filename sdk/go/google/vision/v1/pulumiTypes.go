// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// A bounding polygon for the detected image annotation.
type BoundingPoly struct {
	// The bounding polygon normalized vertices.
	NormalizedVertices []NormalizedVertex `pulumi:"normalizedVertices"`
	// The bounding polygon vertices.
	Vertices []Vertex `pulumi:"vertices"`
}

// BoundingPolyInput is an input type that accepts BoundingPolyArgs and BoundingPolyOutput values.
// You can construct a concrete instance of `BoundingPolyInput` via:
//
//          BoundingPolyArgs{...}
type BoundingPolyInput interface {
	pulumi.Input

	ToBoundingPolyOutput() BoundingPolyOutput
	ToBoundingPolyOutputWithContext(context.Context) BoundingPolyOutput
}

// A bounding polygon for the detected image annotation.
type BoundingPolyArgs struct {
	// The bounding polygon normalized vertices.
	NormalizedVertices NormalizedVertexArrayInput `pulumi:"normalizedVertices"`
	// The bounding polygon vertices.
	Vertices VertexArrayInput `pulumi:"vertices"`
}

func (BoundingPolyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BoundingPoly)(nil)).Elem()
}

func (i BoundingPolyArgs) ToBoundingPolyOutput() BoundingPolyOutput {
	return i.ToBoundingPolyOutputWithContext(context.Background())
}

func (i BoundingPolyArgs) ToBoundingPolyOutputWithContext(ctx context.Context) BoundingPolyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BoundingPolyOutput)
}

// BoundingPolyArrayInput is an input type that accepts BoundingPolyArray and BoundingPolyArrayOutput values.
// You can construct a concrete instance of `BoundingPolyArrayInput` via:
//
//          BoundingPolyArray{ BoundingPolyArgs{...} }
type BoundingPolyArrayInput interface {
	pulumi.Input

	ToBoundingPolyArrayOutput() BoundingPolyArrayOutput
	ToBoundingPolyArrayOutputWithContext(context.Context) BoundingPolyArrayOutput
}

type BoundingPolyArray []BoundingPolyInput

func (BoundingPolyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BoundingPoly)(nil)).Elem()
}

func (i BoundingPolyArray) ToBoundingPolyArrayOutput() BoundingPolyArrayOutput {
	return i.ToBoundingPolyArrayOutputWithContext(context.Background())
}

func (i BoundingPolyArray) ToBoundingPolyArrayOutputWithContext(ctx context.Context) BoundingPolyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BoundingPolyArrayOutput)
}

// A bounding polygon for the detected image annotation.
type BoundingPolyOutput struct{ *pulumi.OutputState }

func (BoundingPolyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BoundingPoly)(nil)).Elem()
}

func (o BoundingPolyOutput) ToBoundingPolyOutput() BoundingPolyOutput {
	return o
}

func (o BoundingPolyOutput) ToBoundingPolyOutputWithContext(ctx context.Context) BoundingPolyOutput {
	return o
}

// The bounding polygon normalized vertices.
func (o BoundingPolyOutput) NormalizedVertices() NormalizedVertexArrayOutput {
	return o.ApplyT(func(v BoundingPoly) []NormalizedVertex { return v.NormalizedVertices }).(NormalizedVertexArrayOutput)
}

// The bounding polygon vertices.
func (o BoundingPolyOutput) Vertices() VertexArrayOutput {
	return o.ApplyT(func(v BoundingPoly) []Vertex { return v.Vertices }).(VertexArrayOutput)
}

type BoundingPolyArrayOutput struct{ *pulumi.OutputState }

func (BoundingPolyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BoundingPoly)(nil)).Elem()
}

func (o BoundingPolyArrayOutput) ToBoundingPolyArrayOutput() BoundingPolyArrayOutput {
	return o
}

func (o BoundingPolyArrayOutput) ToBoundingPolyArrayOutputWithContext(ctx context.Context) BoundingPolyArrayOutput {
	return o
}

func (o BoundingPolyArrayOutput) Index(i pulumi.IntInput) BoundingPolyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BoundingPoly {
		return vs[0].([]BoundingPoly)[vs[1].(int)]
	}).(BoundingPolyOutput)
}

// A product label represented as a key-value pair.
type KeyValue struct {
	// The key of the label attached to the product. Cannot be empty and cannot exceed 128 bytes.
	Key *string `pulumi:"key"`
	// The value of the label attached to the product. Cannot be empty and cannot exceed 128 bytes.
	Value *string `pulumi:"value"`
}

// KeyValueInput is an input type that accepts KeyValueArgs and KeyValueOutput values.
// You can construct a concrete instance of `KeyValueInput` via:
//
//          KeyValueArgs{...}
type KeyValueInput interface {
	pulumi.Input

	ToKeyValueOutput() KeyValueOutput
	ToKeyValueOutputWithContext(context.Context) KeyValueOutput
}

// A product label represented as a key-value pair.
type KeyValueArgs struct {
	// The key of the label attached to the product. Cannot be empty and cannot exceed 128 bytes.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// The value of the label attached to the product. Cannot be empty and cannot exceed 128 bytes.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (KeyValueArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyValue)(nil)).Elem()
}

func (i KeyValueArgs) ToKeyValueOutput() KeyValueOutput {
	return i.ToKeyValueOutputWithContext(context.Background())
}

func (i KeyValueArgs) ToKeyValueOutputWithContext(ctx context.Context) KeyValueOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyValueOutput)
}

// KeyValueArrayInput is an input type that accepts KeyValueArray and KeyValueArrayOutput values.
// You can construct a concrete instance of `KeyValueArrayInput` via:
//
//          KeyValueArray{ KeyValueArgs{...} }
type KeyValueArrayInput interface {
	pulumi.Input

	ToKeyValueArrayOutput() KeyValueArrayOutput
	ToKeyValueArrayOutputWithContext(context.Context) KeyValueArrayOutput
}

type KeyValueArray []KeyValueInput

func (KeyValueArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KeyValue)(nil)).Elem()
}

func (i KeyValueArray) ToKeyValueArrayOutput() KeyValueArrayOutput {
	return i.ToKeyValueArrayOutputWithContext(context.Background())
}

func (i KeyValueArray) ToKeyValueArrayOutputWithContext(ctx context.Context) KeyValueArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyValueArrayOutput)
}

// A product label represented as a key-value pair.
type KeyValueOutput struct{ *pulumi.OutputState }

func (KeyValueOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyValue)(nil)).Elem()
}

func (o KeyValueOutput) ToKeyValueOutput() KeyValueOutput {
	return o
}

func (o KeyValueOutput) ToKeyValueOutputWithContext(ctx context.Context) KeyValueOutput {
	return o
}

// The key of the label attached to the product. Cannot be empty and cannot exceed 128 bytes.
func (o KeyValueOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KeyValue) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// The value of the label attached to the product. Cannot be empty and cannot exceed 128 bytes.
func (o KeyValueOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KeyValue) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type KeyValueArrayOutput struct{ *pulumi.OutputState }

func (KeyValueArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KeyValue)(nil)).Elem()
}

func (o KeyValueArrayOutput) ToKeyValueArrayOutput() KeyValueArrayOutput {
	return o
}

func (o KeyValueArrayOutput) ToKeyValueArrayOutputWithContext(ctx context.Context) KeyValueArrayOutput {
	return o
}

func (o KeyValueArrayOutput) Index(i pulumi.IntInput) KeyValueOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KeyValue {
		return vs[0].([]KeyValue)[vs[1].(int)]
	}).(KeyValueOutput)
}

// A vertex represents a 2D point in the image. NOTE: the normalized vertex coordinates are relative to the original image and range from 0 to 1.
type NormalizedVertex struct {
	// X coordinate.
	X *float64 `pulumi:"x"`
	// Y coordinate.
	Y *float64 `pulumi:"y"`
}

// NormalizedVertexInput is an input type that accepts NormalizedVertexArgs and NormalizedVertexOutput values.
// You can construct a concrete instance of `NormalizedVertexInput` via:
//
//          NormalizedVertexArgs{...}
type NormalizedVertexInput interface {
	pulumi.Input

	ToNormalizedVertexOutput() NormalizedVertexOutput
	ToNormalizedVertexOutputWithContext(context.Context) NormalizedVertexOutput
}

// A vertex represents a 2D point in the image. NOTE: the normalized vertex coordinates are relative to the original image and range from 0 to 1.
type NormalizedVertexArgs struct {
	// X coordinate.
	X pulumi.Float64PtrInput `pulumi:"x"`
	// Y coordinate.
	Y pulumi.Float64PtrInput `pulumi:"y"`
}

func (NormalizedVertexArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NormalizedVertex)(nil)).Elem()
}

func (i NormalizedVertexArgs) ToNormalizedVertexOutput() NormalizedVertexOutput {
	return i.ToNormalizedVertexOutputWithContext(context.Background())
}

func (i NormalizedVertexArgs) ToNormalizedVertexOutputWithContext(ctx context.Context) NormalizedVertexOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NormalizedVertexOutput)
}

// NormalizedVertexArrayInput is an input type that accepts NormalizedVertexArray and NormalizedVertexArrayOutput values.
// You can construct a concrete instance of `NormalizedVertexArrayInput` via:
//
//          NormalizedVertexArray{ NormalizedVertexArgs{...} }
type NormalizedVertexArrayInput interface {
	pulumi.Input

	ToNormalizedVertexArrayOutput() NormalizedVertexArrayOutput
	ToNormalizedVertexArrayOutputWithContext(context.Context) NormalizedVertexArrayOutput
}

type NormalizedVertexArray []NormalizedVertexInput

func (NormalizedVertexArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NormalizedVertex)(nil)).Elem()
}

func (i NormalizedVertexArray) ToNormalizedVertexArrayOutput() NormalizedVertexArrayOutput {
	return i.ToNormalizedVertexArrayOutputWithContext(context.Background())
}

func (i NormalizedVertexArray) ToNormalizedVertexArrayOutputWithContext(ctx context.Context) NormalizedVertexArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NormalizedVertexArrayOutput)
}

// A vertex represents a 2D point in the image. NOTE: the normalized vertex coordinates are relative to the original image and range from 0 to 1.
type NormalizedVertexOutput struct{ *pulumi.OutputState }

func (NormalizedVertexOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NormalizedVertex)(nil)).Elem()
}

func (o NormalizedVertexOutput) ToNormalizedVertexOutput() NormalizedVertexOutput {
	return o
}

func (o NormalizedVertexOutput) ToNormalizedVertexOutputWithContext(ctx context.Context) NormalizedVertexOutput {
	return o
}

// X coordinate.
func (o NormalizedVertexOutput) X() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v NormalizedVertex) *float64 { return v.X }).(pulumi.Float64PtrOutput)
}

// Y coordinate.
func (o NormalizedVertexOutput) Y() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v NormalizedVertex) *float64 { return v.Y }).(pulumi.Float64PtrOutput)
}

type NormalizedVertexArrayOutput struct{ *pulumi.OutputState }

func (NormalizedVertexArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NormalizedVertex)(nil)).Elem()
}

func (o NormalizedVertexArrayOutput) ToNormalizedVertexArrayOutput() NormalizedVertexArrayOutput {
	return o
}

func (o NormalizedVertexArrayOutput) ToNormalizedVertexArrayOutputWithContext(ctx context.Context) NormalizedVertexArrayOutput {
	return o
}

func (o NormalizedVertexArrayOutput) Index(i pulumi.IntInput) NormalizedVertexOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NormalizedVertex {
		return vs[0].([]NormalizedVertex)[vs[1].(int)]
	}).(NormalizedVertexOutput)
}

// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
type Status struct {
	// The status code, which should be an enum value of google.rpc.Code.
	Code *int `pulumi:"code"`
	// A list of messages that carry the error details. There is a common set of message types for APIs to use.
	Details []map[string]string `pulumi:"details"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
	Message *string `pulumi:"message"`
}

// StatusInput is an input type that accepts StatusArgs and StatusOutput values.
// You can construct a concrete instance of `StatusInput` via:
//
//          StatusArgs{...}
type StatusInput interface {
	pulumi.Input

	ToStatusOutput() StatusOutput
	ToStatusOutputWithContext(context.Context) StatusOutput
}

// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
type StatusArgs struct {
	// The status code, which should be an enum value of google.rpc.Code.
	Code pulumi.IntPtrInput `pulumi:"code"`
	// A list of messages that carry the error details. There is a common set of message types for APIs to use.
	Details pulumi.StringMapArrayInput `pulumi:"details"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
	Message pulumi.StringPtrInput `pulumi:"message"`
}

func (StatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Status)(nil)).Elem()
}

func (i StatusArgs) ToStatusOutput() StatusOutput {
	return i.ToStatusOutputWithContext(context.Background())
}

func (i StatusArgs) ToStatusOutputWithContext(ctx context.Context) StatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusOutput)
}

func (i StatusArgs) ToStatusPtrOutput() StatusPtrOutput {
	return i.ToStatusPtrOutputWithContext(context.Background())
}

func (i StatusArgs) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusOutput).ToStatusPtrOutputWithContext(ctx)
}

// StatusPtrInput is an input type that accepts StatusArgs, StatusPtr and StatusPtrOutput values.
// You can construct a concrete instance of `StatusPtrInput` via:
//
//          StatusArgs{...}
//
//  or:
//
//          nil
type StatusPtrInput interface {
	pulumi.Input

	ToStatusPtrOutput() StatusPtrOutput
	ToStatusPtrOutputWithContext(context.Context) StatusPtrOutput
}

type statusPtrType StatusArgs

func StatusPtr(v *StatusArgs) StatusPtrInput {
	return (*statusPtrType)(v)
}

func (*statusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Status)(nil)).Elem()
}

func (i *statusPtrType) ToStatusPtrOutput() StatusPtrOutput {
	return i.ToStatusPtrOutputWithContext(context.Background())
}

func (i *statusPtrType) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusPtrOutput)
}

// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
type StatusOutput struct{ *pulumi.OutputState }

func (StatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Status)(nil)).Elem()
}

func (o StatusOutput) ToStatusOutput() StatusOutput {
	return o
}

func (o StatusOutput) ToStatusOutputWithContext(ctx context.Context) StatusOutput {
	return o
}

func (o StatusOutput) ToStatusPtrOutput() StatusPtrOutput {
	return o.ToStatusPtrOutputWithContext(context.Background())
}

func (o StatusOutput) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return o.ApplyT(func(v Status) *Status {
		return &v
	}).(StatusPtrOutput)
}

// The status code, which should be an enum value of google.rpc.Code.
func (o StatusOutput) Code() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Status) *int { return v.Code }).(pulumi.IntPtrOutput)
}

// A list of messages that carry the error details. There is a common set of message types for APIs to use.
func (o StatusOutput) Details() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v Status) []map[string]string { return v.Details }).(pulumi.StringMapArrayOutput)
}

// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
func (o StatusOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Status) *string { return v.Message }).(pulumi.StringPtrOutput)
}

type StatusPtrOutput struct{ *pulumi.OutputState }

func (StatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Status)(nil)).Elem()
}

func (o StatusPtrOutput) ToStatusPtrOutput() StatusPtrOutput {
	return o
}

func (o StatusPtrOutput) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return o
}

func (o StatusPtrOutput) Elem() StatusOutput {
	return o.ApplyT(func(v *Status) Status { return *v }).(StatusOutput)
}

// The status code, which should be an enum value of google.rpc.Code.
func (o StatusPtrOutput) Code() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Status) *int {
		if v == nil {
			return nil
		}
		return v.Code
	}).(pulumi.IntPtrOutput)
}

// A list of messages that carry the error details. There is a common set of message types for APIs to use.
func (o StatusPtrOutput) Details() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v *Status) []map[string]string {
		if v == nil {
			return nil
		}
		return v.Details
	}).(pulumi.StringMapArrayOutput)
}

// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
func (o StatusPtrOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Status) *string {
		if v == nil {
			return nil
		}
		return v.Message
	}).(pulumi.StringPtrOutput)
}

// A vertex represents a 2D point in the image. NOTE: the vertex coordinates are in the same scale as the original image.
type Vertex struct {
	// X coordinate.
	X *int `pulumi:"x"`
	// Y coordinate.
	Y *int `pulumi:"y"`
}

// VertexInput is an input type that accepts VertexArgs and VertexOutput values.
// You can construct a concrete instance of `VertexInput` via:
//
//          VertexArgs{...}
type VertexInput interface {
	pulumi.Input

	ToVertexOutput() VertexOutput
	ToVertexOutputWithContext(context.Context) VertexOutput
}

// A vertex represents a 2D point in the image. NOTE: the vertex coordinates are in the same scale as the original image.
type VertexArgs struct {
	// X coordinate.
	X pulumi.IntPtrInput `pulumi:"x"`
	// Y coordinate.
	Y pulumi.IntPtrInput `pulumi:"y"`
}

func (VertexArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Vertex)(nil)).Elem()
}

func (i VertexArgs) ToVertexOutput() VertexOutput {
	return i.ToVertexOutputWithContext(context.Background())
}

func (i VertexArgs) ToVertexOutputWithContext(ctx context.Context) VertexOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VertexOutput)
}

// VertexArrayInput is an input type that accepts VertexArray and VertexArrayOutput values.
// You can construct a concrete instance of `VertexArrayInput` via:
//
//          VertexArray{ VertexArgs{...} }
type VertexArrayInput interface {
	pulumi.Input

	ToVertexArrayOutput() VertexArrayOutput
	ToVertexArrayOutputWithContext(context.Context) VertexArrayOutput
}

type VertexArray []VertexInput

func (VertexArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Vertex)(nil)).Elem()
}

func (i VertexArray) ToVertexArrayOutput() VertexArrayOutput {
	return i.ToVertexArrayOutputWithContext(context.Background())
}

func (i VertexArray) ToVertexArrayOutputWithContext(ctx context.Context) VertexArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VertexArrayOutput)
}

// A vertex represents a 2D point in the image. NOTE: the vertex coordinates are in the same scale as the original image.
type VertexOutput struct{ *pulumi.OutputState }

func (VertexOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Vertex)(nil)).Elem()
}

func (o VertexOutput) ToVertexOutput() VertexOutput {
	return o
}

func (o VertexOutput) ToVertexOutputWithContext(ctx context.Context) VertexOutput {
	return o
}

// X coordinate.
func (o VertexOutput) X() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Vertex) *int { return v.X }).(pulumi.IntPtrOutput)
}

// Y coordinate.
func (o VertexOutput) Y() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Vertex) *int { return v.Y }).(pulumi.IntPtrOutput)
}

type VertexArrayOutput struct{ *pulumi.OutputState }

func (VertexArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Vertex)(nil)).Elem()
}

func (o VertexArrayOutput) ToVertexArrayOutput() VertexArrayOutput {
	return o
}

func (o VertexArrayOutput) ToVertexArrayOutputWithContext(ctx context.Context) VertexArrayOutput {
	return o
}

func (o VertexArrayOutput) Index(i pulumi.IntInput) VertexOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Vertex {
		return vs[0].([]Vertex)[vs[1].(int)]
	}).(VertexOutput)
}

func init() {
	pulumi.RegisterOutputType(BoundingPolyOutput{})
	pulumi.RegisterOutputType(BoundingPolyArrayOutput{})
	pulumi.RegisterOutputType(KeyValueOutput{})
	pulumi.RegisterOutputType(KeyValueArrayOutput{})
	pulumi.RegisterOutputType(NormalizedVertexOutput{})
	pulumi.RegisterOutputType(NormalizedVertexArrayOutput{})
	pulumi.RegisterOutputType(StatusOutput{})
	pulumi.RegisterOutputType(StatusPtrOutput{})
	pulumi.RegisterOutputType(VertexOutput{})
	pulumi.RegisterOutputType(VertexArrayOutput{})
}
