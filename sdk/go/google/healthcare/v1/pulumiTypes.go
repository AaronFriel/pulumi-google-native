// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts jose@example.com from DATA_READ logging, and aliya@example.com from DATA_WRITE logging.
type AuditConfig struct {
	// The configuration for logging of each type of permission.
	AuditLogConfigs []AuditLogConfig `pulumi:"auditLogConfigs"`
	// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
	Service *string `pulumi:"service"`
}

// AuditConfigInput is an input type that accepts AuditConfigArgs and AuditConfigOutput values.
// You can construct a concrete instance of `AuditConfigInput` via:
//
//          AuditConfigArgs{...}
type AuditConfigInput interface {
	pulumi.Input

	ToAuditConfigOutput() AuditConfigOutput
	ToAuditConfigOutputWithContext(context.Context) AuditConfigOutput
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts jose@example.com from DATA_READ logging, and aliya@example.com from DATA_WRITE logging.
type AuditConfigArgs struct {
	// The configuration for logging of each type of permission.
	AuditLogConfigs AuditLogConfigArrayInput `pulumi:"auditLogConfigs"`
	// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
	Service pulumi.StringPtrInput `pulumi:"service"`
}

func (AuditConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditConfig)(nil)).Elem()
}

func (i AuditConfigArgs) ToAuditConfigOutput() AuditConfigOutput {
	return i.ToAuditConfigOutputWithContext(context.Background())
}

func (i AuditConfigArgs) ToAuditConfigOutputWithContext(ctx context.Context) AuditConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditConfigOutput)
}

// AuditConfigArrayInput is an input type that accepts AuditConfigArray and AuditConfigArrayOutput values.
// You can construct a concrete instance of `AuditConfigArrayInput` via:
//
//          AuditConfigArray{ AuditConfigArgs{...} }
type AuditConfigArrayInput interface {
	pulumi.Input

	ToAuditConfigArrayOutput() AuditConfigArrayOutput
	ToAuditConfigArrayOutputWithContext(context.Context) AuditConfigArrayOutput
}

type AuditConfigArray []AuditConfigInput

func (AuditConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditConfig)(nil)).Elem()
}

func (i AuditConfigArray) ToAuditConfigArrayOutput() AuditConfigArrayOutput {
	return i.ToAuditConfigArrayOutputWithContext(context.Background())
}

func (i AuditConfigArray) ToAuditConfigArrayOutputWithContext(ctx context.Context) AuditConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditConfigArrayOutput)
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts jose@example.com from DATA_READ logging, and aliya@example.com from DATA_WRITE logging.
type AuditConfigOutput struct{ *pulumi.OutputState }

func (AuditConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditConfig)(nil)).Elem()
}

func (o AuditConfigOutput) ToAuditConfigOutput() AuditConfigOutput {
	return o
}

func (o AuditConfigOutput) ToAuditConfigOutputWithContext(ctx context.Context) AuditConfigOutput {
	return o
}

// The configuration for logging of each type of permission.
func (o AuditConfigOutput) AuditLogConfigs() AuditLogConfigArrayOutput {
	return o.ApplyT(func(v AuditConfig) []AuditLogConfig { return v.AuditLogConfigs }).(AuditLogConfigArrayOutput)
}

// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
func (o AuditConfigOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AuditConfig) *string { return v.Service }).(pulumi.StringPtrOutput)
}

type AuditConfigArrayOutput struct{ *pulumi.OutputState }

func (AuditConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditConfig)(nil)).Elem()
}

func (o AuditConfigArrayOutput) ToAuditConfigArrayOutput() AuditConfigArrayOutput {
	return o
}

func (o AuditConfigArrayOutput) ToAuditConfigArrayOutputWithContext(ctx context.Context) AuditConfigArrayOutput {
	return o
}

func (o AuditConfigArrayOutput) Index(i pulumi.IntInput) AuditConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AuditConfig {
		return vs[0].([]AuditConfig)[vs[1].(int)]
	}).(AuditConfigOutput)
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfig struct {
	// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
	ExemptedMembers []string `pulumi:"exemptedMembers"`
	// The log type that this config enables.
	LogType *string `pulumi:"logType"`
}

// AuditLogConfigInput is an input type that accepts AuditLogConfigArgs and AuditLogConfigOutput values.
// You can construct a concrete instance of `AuditLogConfigInput` via:
//
//          AuditLogConfigArgs{...}
type AuditLogConfigInput interface {
	pulumi.Input

	ToAuditLogConfigOutput() AuditLogConfigOutput
	ToAuditLogConfigOutputWithContext(context.Context) AuditLogConfigOutput
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfigArgs struct {
	// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
	ExemptedMembers pulumi.StringArrayInput `pulumi:"exemptedMembers"`
	// The log type that this config enables.
	LogType pulumi.StringPtrInput `pulumi:"logType"`
}

func (AuditLogConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditLogConfig)(nil)).Elem()
}

func (i AuditLogConfigArgs) ToAuditLogConfigOutput() AuditLogConfigOutput {
	return i.ToAuditLogConfigOutputWithContext(context.Background())
}

func (i AuditLogConfigArgs) ToAuditLogConfigOutputWithContext(ctx context.Context) AuditLogConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditLogConfigOutput)
}

// AuditLogConfigArrayInput is an input type that accepts AuditLogConfigArray and AuditLogConfigArrayOutput values.
// You can construct a concrete instance of `AuditLogConfigArrayInput` via:
//
//          AuditLogConfigArray{ AuditLogConfigArgs{...} }
type AuditLogConfigArrayInput interface {
	pulumi.Input

	ToAuditLogConfigArrayOutput() AuditLogConfigArrayOutput
	ToAuditLogConfigArrayOutputWithContext(context.Context) AuditLogConfigArrayOutput
}

type AuditLogConfigArray []AuditLogConfigInput

func (AuditLogConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditLogConfig)(nil)).Elem()
}

func (i AuditLogConfigArray) ToAuditLogConfigArrayOutput() AuditLogConfigArrayOutput {
	return i.ToAuditLogConfigArrayOutputWithContext(context.Background())
}

func (i AuditLogConfigArray) ToAuditLogConfigArrayOutputWithContext(ctx context.Context) AuditLogConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditLogConfigArrayOutput)
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfigOutput struct{ *pulumi.OutputState }

func (AuditLogConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditLogConfig)(nil)).Elem()
}

func (o AuditLogConfigOutput) ToAuditLogConfigOutput() AuditLogConfigOutput {
	return o
}

func (o AuditLogConfigOutput) ToAuditLogConfigOutputWithContext(ctx context.Context) AuditLogConfigOutput {
	return o
}

// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
func (o AuditLogConfigOutput) ExemptedMembers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AuditLogConfig) []string { return v.ExemptedMembers }).(pulumi.StringArrayOutput)
}

// The log type that this config enables.
func (o AuditLogConfigOutput) LogType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AuditLogConfig) *string { return v.LogType }).(pulumi.StringPtrOutput)
}

type AuditLogConfigArrayOutput struct{ *pulumi.OutputState }

func (AuditLogConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditLogConfig)(nil)).Elem()
}

func (o AuditLogConfigArrayOutput) ToAuditLogConfigArrayOutput() AuditLogConfigArrayOutput {
	return o
}

func (o AuditLogConfigArrayOutput) ToAuditLogConfigArrayOutputWithContext(ctx context.Context) AuditLogConfigArrayOutput {
	return o
}

func (o AuditLogConfigArrayOutput) Index(i pulumi.IntInput) AuditLogConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AuditLogConfig {
		return vs[0].([]AuditLogConfig)[vs[1].(int)]
	}).(AuditLogConfigOutput)
}

// Associates `members` with a `role`.
type Binding struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition *Expr `pulumi:"condition"`
	// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
	Members []string `pulumi:"members"`
	// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
	Role *string `pulumi:"role"`
}

// BindingInput is an input type that accepts BindingArgs and BindingOutput values.
// You can construct a concrete instance of `BindingInput` via:
//
//          BindingArgs{...}
type BindingInput interface {
	pulumi.Input

	ToBindingOutput() BindingOutput
	ToBindingOutputWithContext(context.Context) BindingOutput
}

// Associates `members` with a `role`.
type BindingArgs struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition ExprPtrInput `pulumi:"condition"`
	// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
	Members pulumi.StringArrayInput `pulumi:"members"`
	// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
	Role pulumi.StringPtrInput `pulumi:"role"`
}

func (BindingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Binding)(nil)).Elem()
}

func (i BindingArgs) ToBindingOutput() BindingOutput {
	return i.ToBindingOutputWithContext(context.Background())
}

func (i BindingArgs) ToBindingOutputWithContext(ctx context.Context) BindingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingOutput)
}

// BindingArrayInput is an input type that accepts BindingArray and BindingArrayOutput values.
// You can construct a concrete instance of `BindingArrayInput` via:
//
//          BindingArray{ BindingArgs{...} }
type BindingArrayInput interface {
	pulumi.Input

	ToBindingArrayOutput() BindingArrayOutput
	ToBindingArrayOutputWithContext(context.Context) BindingArrayOutput
}

type BindingArray []BindingInput

func (BindingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Binding)(nil)).Elem()
}

func (i BindingArray) ToBindingArrayOutput() BindingArrayOutput {
	return i.ToBindingArrayOutputWithContext(context.Background())
}

func (i BindingArray) ToBindingArrayOutputWithContext(ctx context.Context) BindingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingArrayOutput)
}

// Associates `members` with a `role`.
type BindingOutput struct{ *pulumi.OutputState }

func (BindingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Binding)(nil)).Elem()
}

func (o BindingOutput) ToBindingOutput() BindingOutput {
	return o
}

func (o BindingOutput) ToBindingOutputWithContext(ctx context.Context) BindingOutput {
	return o
}

// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o BindingOutput) Condition() ExprPtrOutput {
	return o.ApplyT(func(v Binding) *Expr { return v.Condition }).(ExprPtrOutput)
}

// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
func (o BindingOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Binding) []string { return v.Members }).(pulumi.StringArrayOutput)
}

// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
func (o BindingOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Binding) *string { return v.Role }).(pulumi.StringPtrOutput)
}

type BindingArrayOutput struct{ *pulumi.OutputState }

func (BindingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Binding)(nil)).Elem()
}

func (o BindingArrayOutput) ToBindingArrayOutput() BindingArrayOutput {
	return o
}

func (o BindingArrayOutput) ToBindingArrayOutputWithContext(ctx context.Context) BindingArrayOutput {
	return o
}

func (o BindingArrayOutput) Index(i pulumi.IntInput) BindingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Binding {
		return vs[0].([]Binding)[vs[1].(int)]
	}).(BindingOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type Expr struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description *string `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression *string `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location *string `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title *string `pulumi:"title"`
}

// ExprInput is an input type that accepts ExprArgs and ExprOutput values.
// You can construct a concrete instance of `ExprInput` via:
//
//          ExprArgs{...}
type ExprInput interface {
	pulumi.Input

	ToExprOutput() ExprOutput
	ToExprOutputWithContext(context.Context) ExprOutput
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprArgs struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression pulumi.StringPtrInput `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title pulumi.StringPtrInput `pulumi:"title"`
}

func (ExprArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (i ExprArgs) ToExprOutput() ExprOutput {
	return i.ToExprOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput)
}

func (i ExprArgs) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput).ToExprPtrOutputWithContext(ctx)
}

// ExprPtrInput is an input type that accepts ExprArgs, ExprPtr and ExprPtrOutput values.
// You can construct a concrete instance of `ExprPtrInput` via:
//
//          ExprArgs{...}
//
//  or:
//
//          nil
type ExprPtrInput interface {
	pulumi.Input

	ToExprPtrOutput() ExprPtrOutput
	ToExprPtrOutputWithContext(context.Context) ExprPtrOutput
}

type exprPtrType ExprArgs

func ExprPtr(v *ExprArgs) ExprPtrInput {
	return (*exprPtrType)(v)
}

func (*exprPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (i *exprPtrType) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i *exprPtrType) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprPtrOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprOutput struct{ *pulumi.OutputState }

func (ExprOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (o ExprOutput) ToExprOutput() ExprOutput {
	return o
}

func (o ExprOutput) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return o
}

func (o ExprOutput) ToExprPtrOutput() ExprPtrOutput {
	return o.ToExprPtrOutputWithContext(context.Background())
}

func (o ExprOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o.ApplyT(func(v Expr) *Expr {
		return &v
	}).(ExprPtrOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Expression }).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Title }).(pulumi.StringPtrOutput)
}

type ExprPtrOutput struct{ *pulumi.OutputState }

func (ExprPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (o ExprPtrOutput) ToExprPtrOutput() ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) Elem() ExprOutput {
	return o.ApplyT(func(v *Expr) Expr { return *v }).(ExprOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprPtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprPtrOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Expression
	}).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprPtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprPtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// The configuration for exporting to BigQuery.
type GoogleCloudHealthcareV1FhirBigQueryDestination struct {
	// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
	DatasetUri *string `pulumi:"datasetUri"`
	// If this flag is `TRUE`, all tables are deleted from the dataset before the new exported tables are written. If the flag is not set and the destination dataset contains tables, the export call returns an error.
	Force *bool `pulumi:"force"`
	// The configuration for the exported BigQuery schema.
	SchemaConfig *SchemaConfig `pulumi:"schemaConfig"`
}

// GoogleCloudHealthcareV1FhirBigQueryDestinationInput is an input type that accepts GoogleCloudHealthcareV1FhirBigQueryDestinationArgs and GoogleCloudHealthcareV1FhirBigQueryDestinationOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1FhirBigQueryDestinationInput` via:
//
//          GoogleCloudHealthcareV1FhirBigQueryDestinationArgs{...}
type GoogleCloudHealthcareV1FhirBigQueryDestinationInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1FhirBigQueryDestinationOutput() GoogleCloudHealthcareV1FhirBigQueryDestinationOutput
	ToGoogleCloudHealthcareV1FhirBigQueryDestinationOutputWithContext(context.Context) GoogleCloudHealthcareV1FhirBigQueryDestinationOutput
}

// The configuration for exporting to BigQuery.
type GoogleCloudHealthcareV1FhirBigQueryDestinationArgs struct {
	// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
	DatasetUri pulumi.StringPtrInput `pulumi:"datasetUri"`
	// If this flag is `TRUE`, all tables are deleted from the dataset before the new exported tables are written. If the flag is not set and the destination dataset contains tables, the export call returns an error.
	Force pulumi.BoolPtrInput `pulumi:"force"`
	// The configuration for the exported BigQuery schema.
	SchemaConfig SchemaConfigPtrInput `pulumi:"schemaConfig"`
}

func (GoogleCloudHealthcareV1FhirBigQueryDestinationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1FhirBigQueryDestination)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1FhirBigQueryDestinationArgs) ToGoogleCloudHealthcareV1FhirBigQueryDestinationOutput() GoogleCloudHealthcareV1FhirBigQueryDestinationOutput {
	return i.ToGoogleCloudHealthcareV1FhirBigQueryDestinationOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1FhirBigQueryDestinationArgs) ToGoogleCloudHealthcareV1FhirBigQueryDestinationOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1FhirBigQueryDestinationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1FhirBigQueryDestinationOutput)
}

func (i GoogleCloudHealthcareV1FhirBigQueryDestinationArgs) ToGoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput {
	return i.ToGoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1FhirBigQueryDestinationArgs) ToGoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1FhirBigQueryDestinationOutput).ToGoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutputWithContext(ctx)
}

// GoogleCloudHealthcareV1FhirBigQueryDestinationPtrInput is an input type that accepts GoogleCloudHealthcareV1FhirBigQueryDestinationArgs, GoogleCloudHealthcareV1FhirBigQueryDestinationPtr and GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1FhirBigQueryDestinationPtrInput` via:
//
//          GoogleCloudHealthcareV1FhirBigQueryDestinationArgs{...}
//
//  or:
//
//          nil
type GoogleCloudHealthcareV1FhirBigQueryDestinationPtrInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput
	ToGoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutputWithContext(context.Context) GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput
}

type googleCloudHealthcareV1FhirBigQueryDestinationPtrType GoogleCloudHealthcareV1FhirBigQueryDestinationArgs

func GoogleCloudHealthcareV1FhirBigQueryDestinationPtr(v *GoogleCloudHealthcareV1FhirBigQueryDestinationArgs) GoogleCloudHealthcareV1FhirBigQueryDestinationPtrInput {
	return (*googleCloudHealthcareV1FhirBigQueryDestinationPtrType)(v)
}

func (*googleCloudHealthcareV1FhirBigQueryDestinationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleCloudHealthcareV1FhirBigQueryDestination)(nil)).Elem()
}

func (i *googleCloudHealthcareV1FhirBigQueryDestinationPtrType) ToGoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput {
	return i.ToGoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutputWithContext(context.Background())
}

func (i *googleCloudHealthcareV1FhirBigQueryDestinationPtrType) ToGoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput)
}

// The configuration for exporting to BigQuery.
type GoogleCloudHealthcareV1FhirBigQueryDestinationOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1FhirBigQueryDestinationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1FhirBigQueryDestination)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1FhirBigQueryDestinationOutput) ToGoogleCloudHealthcareV1FhirBigQueryDestinationOutput() GoogleCloudHealthcareV1FhirBigQueryDestinationOutput {
	return o
}

func (o GoogleCloudHealthcareV1FhirBigQueryDestinationOutput) ToGoogleCloudHealthcareV1FhirBigQueryDestinationOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1FhirBigQueryDestinationOutput {
	return o
}

func (o GoogleCloudHealthcareV1FhirBigQueryDestinationOutput) ToGoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput {
	return o.ToGoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutputWithContext(context.Background())
}

func (o GoogleCloudHealthcareV1FhirBigQueryDestinationOutput) ToGoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1FhirBigQueryDestination) *GoogleCloudHealthcareV1FhirBigQueryDestination {
		return &v
	}).(GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput)
}

// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
func (o GoogleCloudHealthcareV1FhirBigQueryDestinationOutput) DatasetUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1FhirBigQueryDestination) *string { return v.DatasetUri }).(pulumi.StringPtrOutput)
}

// If this flag is `TRUE`, all tables are deleted from the dataset before the new exported tables are written. If the flag is not set and the destination dataset contains tables, the export call returns an error.
func (o GoogleCloudHealthcareV1FhirBigQueryDestinationOutput) Force() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1FhirBigQueryDestination) *bool { return v.Force }).(pulumi.BoolPtrOutput)
}

// The configuration for the exported BigQuery schema.
func (o GoogleCloudHealthcareV1FhirBigQueryDestinationOutput) SchemaConfig() SchemaConfigPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1FhirBigQueryDestination) *SchemaConfig { return v.SchemaConfig }).(SchemaConfigPtrOutput)
}

type GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleCloudHealthcareV1FhirBigQueryDestination)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput) ToGoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput {
	return o
}

func (o GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput) ToGoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput {
	return o
}

func (o GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput) Elem() GoogleCloudHealthcareV1FhirBigQueryDestinationOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1FhirBigQueryDestination) GoogleCloudHealthcareV1FhirBigQueryDestination {
		return *v
	}).(GoogleCloudHealthcareV1FhirBigQueryDestinationOutput)
}

// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
func (o GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput) DatasetUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1FhirBigQueryDestination) *string {
		if v == nil {
			return nil
		}
		return v.DatasetUri
	}).(pulumi.StringPtrOutput)
}

// If this flag is `TRUE`, all tables are deleted from the dataset before the new exported tables are written. If the flag is not set and the destination dataset contains tables, the export call returns an error.
func (o GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput) Force() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1FhirBigQueryDestination) *bool {
		if v == nil {
			return nil
		}
		return v.Force
	}).(pulumi.BoolPtrOutput)
}

// The configuration for the exported BigQuery schema.
func (o GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput) SchemaConfig() SchemaConfigPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1FhirBigQueryDestination) *SchemaConfig {
		if v == nil {
			return nil
		}
		return v.SchemaConfig
	}).(SchemaConfigPtrOutput)
}

// Specifies where and whether to send notifications upon changes to a data store.
type Hl7V2NotificationConfig struct {
	// Restricts notifications sent for messages matching a filter. If this is empty, all messages are matched. Syntax: https://cloud.google.com/appengine/docs/standard/python/search/query_strings The following fields and functions are available for filtering: * `message_type`, from the MSH-9.1 field. For example, `NOT message_type = "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was sent in the dataset's time_zone, from the MSH-7 segment. For example, `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care center that the message came from, from the MSH-4 segment. For example, `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`. * `labels.x`, a string value of the label with key `x` as set using the Message.labels map. For example, `labels."priority"="high"`. The operator `:*` can be used to assert the existence of a label. For example, `labels."priority":*`.
	Filter *string `pulumi:"filter"`
	// The [Cloud Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It's guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. The Cloud Healthcare API service account, service-PROJECT_NUMBER@gcp-sa-healthcare.iam.gserviceaccount.com, must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification cannot be published to Cloud Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](/healthcare/docs/how-tos/logging)).
	PubsubTopic *string `pulumi:"pubsubTopic"`
}

// Hl7V2NotificationConfigInput is an input type that accepts Hl7V2NotificationConfigArgs and Hl7V2NotificationConfigOutput values.
// You can construct a concrete instance of `Hl7V2NotificationConfigInput` via:
//
//          Hl7V2NotificationConfigArgs{...}
type Hl7V2NotificationConfigInput interface {
	pulumi.Input

	ToHl7V2NotificationConfigOutput() Hl7V2NotificationConfigOutput
	ToHl7V2NotificationConfigOutputWithContext(context.Context) Hl7V2NotificationConfigOutput
}

// Specifies where and whether to send notifications upon changes to a data store.
type Hl7V2NotificationConfigArgs struct {
	// Restricts notifications sent for messages matching a filter. If this is empty, all messages are matched. Syntax: https://cloud.google.com/appengine/docs/standard/python/search/query_strings The following fields and functions are available for filtering: * `message_type`, from the MSH-9.1 field. For example, `NOT message_type = "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was sent in the dataset's time_zone, from the MSH-7 segment. For example, `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care center that the message came from, from the MSH-4 segment. For example, `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`. * `labels.x`, a string value of the label with key `x` as set using the Message.labels map. For example, `labels."priority"="high"`. The operator `:*` can be used to assert the existence of a label. For example, `labels."priority":*`.
	Filter pulumi.StringPtrInput `pulumi:"filter"`
	// The [Cloud Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It's guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. The Cloud Healthcare API service account, service-PROJECT_NUMBER@gcp-sa-healthcare.iam.gserviceaccount.com, must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification cannot be published to Cloud Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](/healthcare/docs/how-tos/logging)).
	PubsubTopic pulumi.StringPtrInput `pulumi:"pubsubTopic"`
}

func (Hl7V2NotificationConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7V2NotificationConfig)(nil)).Elem()
}

func (i Hl7V2NotificationConfigArgs) ToHl7V2NotificationConfigOutput() Hl7V2NotificationConfigOutput {
	return i.ToHl7V2NotificationConfigOutputWithContext(context.Background())
}

func (i Hl7V2NotificationConfigArgs) ToHl7V2NotificationConfigOutputWithContext(ctx context.Context) Hl7V2NotificationConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7V2NotificationConfigOutput)
}

// Hl7V2NotificationConfigArrayInput is an input type that accepts Hl7V2NotificationConfigArray and Hl7V2NotificationConfigArrayOutput values.
// You can construct a concrete instance of `Hl7V2NotificationConfigArrayInput` via:
//
//          Hl7V2NotificationConfigArray{ Hl7V2NotificationConfigArgs{...} }
type Hl7V2NotificationConfigArrayInput interface {
	pulumi.Input

	ToHl7V2NotificationConfigArrayOutput() Hl7V2NotificationConfigArrayOutput
	ToHl7V2NotificationConfigArrayOutputWithContext(context.Context) Hl7V2NotificationConfigArrayOutput
}

type Hl7V2NotificationConfigArray []Hl7V2NotificationConfigInput

func (Hl7V2NotificationConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7V2NotificationConfig)(nil)).Elem()
}

func (i Hl7V2NotificationConfigArray) ToHl7V2NotificationConfigArrayOutput() Hl7V2NotificationConfigArrayOutput {
	return i.ToHl7V2NotificationConfigArrayOutputWithContext(context.Background())
}

func (i Hl7V2NotificationConfigArray) ToHl7V2NotificationConfigArrayOutputWithContext(ctx context.Context) Hl7V2NotificationConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7V2NotificationConfigArrayOutput)
}

// Specifies where and whether to send notifications upon changes to a data store.
type Hl7V2NotificationConfigOutput struct{ *pulumi.OutputState }

func (Hl7V2NotificationConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7V2NotificationConfig)(nil)).Elem()
}

func (o Hl7V2NotificationConfigOutput) ToHl7V2NotificationConfigOutput() Hl7V2NotificationConfigOutput {
	return o
}

func (o Hl7V2NotificationConfigOutput) ToHl7V2NotificationConfigOutputWithContext(ctx context.Context) Hl7V2NotificationConfigOutput {
	return o
}

// Restricts notifications sent for messages matching a filter. If this is empty, all messages are matched. Syntax: https://cloud.google.com/appengine/docs/standard/python/search/query_strings The following fields and functions are available for filtering: * `message_type`, from the MSH-9.1 field. For example, `NOT message_type = "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was sent in the dataset's time_zone, from the MSH-7 segment. For example, `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care center that the message came from, from the MSH-4 segment. For example, `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`. * `labels.x`, a string value of the label with key `x` as set using the Message.labels map. For example, `labels."priority"="high"`. The operator `:*` can be used to assert the existence of a label. For example, `labels."priority":*`.
func (o Hl7V2NotificationConfigOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Hl7V2NotificationConfig) *string { return v.Filter }).(pulumi.StringPtrOutput)
}

// The [Cloud Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It's guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. The Cloud Healthcare API service account, service-PROJECT_NUMBER@gcp-sa-healthcare.iam.gserviceaccount.com, must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification cannot be published to Cloud Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](/healthcare/docs/how-tos/logging)).
func (o Hl7V2NotificationConfigOutput) PubsubTopic() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Hl7V2NotificationConfig) *string { return v.PubsubTopic }).(pulumi.StringPtrOutput)
}

type Hl7V2NotificationConfigArrayOutput struct{ *pulumi.OutputState }

func (Hl7V2NotificationConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7V2NotificationConfig)(nil)).Elem()
}

func (o Hl7V2NotificationConfigArrayOutput) ToHl7V2NotificationConfigArrayOutput() Hl7V2NotificationConfigArrayOutput {
	return o
}

func (o Hl7V2NotificationConfigArrayOutput) ToHl7V2NotificationConfigArrayOutputWithContext(ctx context.Context) Hl7V2NotificationConfigArrayOutput {
	return o
}

func (o Hl7V2NotificationConfigArrayOutput) Index(i pulumi.IntInput) Hl7V2NotificationConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Hl7V2NotificationConfig {
		return vs[0].([]Hl7V2NotificationConfig)[vs[1].(int)]
	}).(Hl7V2NotificationConfigOutput)
}

// A complete HL7v2 message. See [Introduction to HL7 Standards] (https://www.hl7.org/implement/standards/index.cfm?ref=common) for details on the standard.
type MessageType struct {
	// Output only. The datetime when the message was created. Set by the server.
	CreateTime *string `pulumi:"createTime"`
	// Raw message bytes.
	Data *string `pulumi:"data"`
	// User-supplied key-value pairs used to organize HL7v2 stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: \p{Ll}\p{Lo}{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63} No more than 64 labels can be associated with a given store.
	Labels map[string]string `pulumi:"labels"`
	// The message type for this message. MSH-9.1.
	MessageType *string `pulumi:"messageType"`
	// Resource name of the Message, of the form `projects/{project_id}/datasets/{dataset_id}/hl7V2Stores/{hl7_v2_store_id}/messages/{message_id}`. Assigned by the server.
	Name *string `pulumi:"name"`
	// Output only. The parsed version of the raw message data.
	ParsedData *ParsedData `pulumi:"parsedData"`
	// All patient IDs listed in the PID-2, PID-3, and PID-4 segments of this message.
	PatientIds []PatientId `pulumi:"patientIds"`
	// The hospital that this message came from. MSH-4.
	SendFacility *string `pulumi:"sendFacility"`
	// The datetime the sending application sent this message. MSH-7.
	SendTime *string `pulumi:"sendTime"`
}

// MessageTypeInput is an input type that accepts MessageTypeArgs and MessageTypeOutput values.
// You can construct a concrete instance of `MessageTypeInput` via:
//
//          MessageTypeArgs{...}
type MessageTypeInput interface {
	pulumi.Input

	ToMessageTypeOutput() MessageTypeOutput
	ToMessageTypeOutputWithContext(context.Context) MessageTypeOutput
}

// A complete HL7v2 message. See [Introduction to HL7 Standards] (https://www.hl7.org/implement/standards/index.cfm?ref=common) for details on the standard.
type MessageTypeArgs struct {
	// Output only. The datetime when the message was created. Set by the server.
	CreateTime pulumi.StringPtrInput `pulumi:"createTime"`
	// Raw message bytes.
	Data pulumi.StringPtrInput `pulumi:"data"`
	// User-supplied key-value pairs used to organize HL7v2 stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: \p{Ll}\p{Lo}{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63} No more than 64 labels can be associated with a given store.
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// The message type for this message. MSH-9.1.
	MessageType pulumi.StringPtrInput `pulumi:"messageType"`
	// Resource name of the Message, of the form `projects/{project_id}/datasets/{dataset_id}/hl7V2Stores/{hl7_v2_store_id}/messages/{message_id}`. Assigned by the server.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Output only. The parsed version of the raw message data.
	ParsedData ParsedDataPtrInput `pulumi:"parsedData"`
	// All patient IDs listed in the PID-2, PID-3, and PID-4 segments of this message.
	PatientIds PatientIdArrayInput `pulumi:"patientIds"`
	// The hospital that this message came from. MSH-4.
	SendFacility pulumi.StringPtrInput `pulumi:"sendFacility"`
	// The datetime the sending application sent this message. MSH-7.
	SendTime pulumi.StringPtrInput `pulumi:"sendTime"`
}

func (MessageTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MessageType)(nil)).Elem()
}

func (i MessageTypeArgs) ToMessageTypeOutput() MessageTypeOutput {
	return i.ToMessageTypeOutputWithContext(context.Background())
}

func (i MessageTypeArgs) ToMessageTypeOutputWithContext(ctx context.Context) MessageTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MessageTypeOutput)
}

func (i MessageTypeArgs) ToMessageTypePtrOutput() MessageTypePtrOutput {
	return i.ToMessageTypePtrOutputWithContext(context.Background())
}

func (i MessageTypeArgs) ToMessageTypePtrOutputWithContext(ctx context.Context) MessageTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MessageTypeOutput).ToMessageTypePtrOutputWithContext(ctx)
}

// MessageTypePtrInput is an input type that accepts MessageTypeArgs, MessageTypePtr and MessageTypePtrOutput values.
// You can construct a concrete instance of `MessageTypePtrInput` via:
//
//          MessageTypeArgs{...}
//
//  or:
//
//          nil
type MessageTypePtrInput interface {
	pulumi.Input

	ToMessageTypePtrOutput() MessageTypePtrOutput
	ToMessageTypePtrOutputWithContext(context.Context) MessageTypePtrOutput
}

type messageTypePtrType MessageTypeArgs

func MessageTypePtr(v *MessageTypeArgs) MessageTypePtrInput {
	return (*messageTypePtrType)(v)
}

func (*messageTypePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MessageType)(nil)).Elem()
}

func (i *messageTypePtrType) ToMessageTypePtrOutput() MessageTypePtrOutput {
	return i.ToMessageTypePtrOutputWithContext(context.Background())
}

func (i *messageTypePtrType) ToMessageTypePtrOutputWithContext(ctx context.Context) MessageTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MessageTypePtrOutput)
}

// A complete HL7v2 message. See [Introduction to HL7 Standards] (https://www.hl7.org/implement/standards/index.cfm?ref=common) for details on the standard.
type MessageTypeOutput struct{ *pulumi.OutputState }

func (MessageTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MessageType)(nil)).Elem()
}

func (o MessageTypeOutput) ToMessageTypeOutput() MessageTypeOutput {
	return o
}

func (o MessageTypeOutput) ToMessageTypeOutputWithContext(ctx context.Context) MessageTypeOutput {
	return o
}

func (o MessageTypeOutput) ToMessageTypePtrOutput() MessageTypePtrOutput {
	return o.ToMessageTypePtrOutputWithContext(context.Background())
}

func (o MessageTypeOutput) ToMessageTypePtrOutputWithContext(ctx context.Context) MessageTypePtrOutput {
	return o.ApplyT(func(v MessageType) *MessageType {
		return &v
	}).(MessageTypePtrOutput)
}

// Output only. The datetime when the message was created. Set by the server.
func (o MessageTypeOutput) CreateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MessageType) *string { return v.CreateTime }).(pulumi.StringPtrOutput)
}

// Raw message bytes.
func (o MessageTypeOutput) Data() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MessageType) *string { return v.Data }).(pulumi.StringPtrOutput)
}

// User-supplied key-value pairs used to organize HL7v2 stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: \p{Ll}\p{Lo}{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63} No more than 64 labels can be associated with a given store.
func (o MessageTypeOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v MessageType) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// The message type for this message. MSH-9.1.
func (o MessageTypeOutput) MessageType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MessageType) *string { return v.MessageType }).(pulumi.StringPtrOutput)
}

// Resource name of the Message, of the form `projects/{project_id}/datasets/{dataset_id}/hl7V2Stores/{hl7_v2_store_id}/messages/{message_id}`. Assigned by the server.
func (o MessageTypeOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MessageType) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Output only. The parsed version of the raw message data.
func (o MessageTypeOutput) ParsedData() ParsedDataPtrOutput {
	return o.ApplyT(func(v MessageType) *ParsedData { return v.ParsedData }).(ParsedDataPtrOutput)
}

// All patient IDs listed in the PID-2, PID-3, and PID-4 segments of this message.
func (o MessageTypeOutput) PatientIds() PatientIdArrayOutput {
	return o.ApplyT(func(v MessageType) []PatientId { return v.PatientIds }).(PatientIdArrayOutput)
}

// The hospital that this message came from. MSH-4.
func (o MessageTypeOutput) SendFacility() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MessageType) *string { return v.SendFacility }).(pulumi.StringPtrOutput)
}

// The datetime the sending application sent this message. MSH-7.
func (o MessageTypeOutput) SendTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MessageType) *string { return v.SendTime }).(pulumi.StringPtrOutput)
}

type MessageTypePtrOutput struct{ *pulumi.OutputState }

func (MessageTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MessageType)(nil)).Elem()
}

func (o MessageTypePtrOutput) ToMessageTypePtrOutput() MessageTypePtrOutput {
	return o
}

func (o MessageTypePtrOutput) ToMessageTypePtrOutputWithContext(ctx context.Context) MessageTypePtrOutput {
	return o
}

func (o MessageTypePtrOutput) Elem() MessageTypeOutput {
	return o.ApplyT(func(v *MessageType) MessageType { return *v }).(MessageTypeOutput)
}

// Output only. The datetime when the message was created. Set by the server.
func (o MessageTypePtrOutput) CreateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MessageType) *string {
		if v == nil {
			return nil
		}
		return v.CreateTime
	}).(pulumi.StringPtrOutput)
}

// Raw message bytes.
func (o MessageTypePtrOutput) Data() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MessageType) *string {
		if v == nil {
			return nil
		}
		return v.Data
	}).(pulumi.StringPtrOutput)
}

// User-supplied key-value pairs used to organize HL7v2 stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: \p{Ll}\p{Lo}{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63} No more than 64 labels can be associated with a given store.
func (o MessageTypePtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *MessageType) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// The message type for this message. MSH-9.1.
func (o MessageTypePtrOutput) MessageType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MessageType) *string {
		if v == nil {
			return nil
		}
		return v.MessageType
	}).(pulumi.StringPtrOutput)
}

// Resource name of the Message, of the form `projects/{project_id}/datasets/{dataset_id}/hl7V2Stores/{hl7_v2_store_id}/messages/{message_id}`. Assigned by the server.
func (o MessageTypePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MessageType) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Output only. The parsed version of the raw message data.
func (o MessageTypePtrOutput) ParsedData() ParsedDataPtrOutput {
	return o.ApplyT(func(v *MessageType) *ParsedData {
		if v == nil {
			return nil
		}
		return v.ParsedData
	}).(ParsedDataPtrOutput)
}

// All patient IDs listed in the PID-2, PID-3, and PID-4 segments of this message.
func (o MessageTypePtrOutput) PatientIds() PatientIdArrayOutput {
	return o.ApplyT(func(v *MessageType) []PatientId {
		if v == nil {
			return nil
		}
		return v.PatientIds
	}).(PatientIdArrayOutput)
}

// The hospital that this message came from. MSH-4.
func (o MessageTypePtrOutput) SendFacility() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MessageType) *string {
		if v == nil {
			return nil
		}
		return v.SendFacility
	}).(pulumi.StringPtrOutput)
}

// The datetime the sending application sent this message. MSH-7.
func (o MessageTypePtrOutput) SendTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MessageType) *string {
		if v == nil {
			return nil
		}
		return v.SendTime
	}).(pulumi.StringPtrOutput)
}

// Specifies where to send notifications upon changes to a data store.
type NotificationConfig struct {
	// The [Cloud Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Cloud Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Cloud Pub/Sub, errors are logged to Cloud Logging (see [Viewing logs](/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
	PubsubTopic *string `pulumi:"pubsubTopic"`
}

// NotificationConfigInput is an input type that accepts NotificationConfigArgs and NotificationConfigOutput values.
// You can construct a concrete instance of `NotificationConfigInput` via:
//
//          NotificationConfigArgs{...}
type NotificationConfigInput interface {
	pulumi.Input

	ToNotificationConfigOutput() NotificationConfigOutput
	ToNotificationConfigOutputWithContext(context.Context) NotificationConfigOutput
}

// Specifies where to send notifications upon changes to a data store.
type NotificationConfigArgs struct {
	// The [Cloud Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Cloud Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Cloud Pub/Sub, errors are logged to Cloud Logging (see [Viewing logs](/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
	PubsubTopic pulumi.StringPtrInput `pulumi:"pubsubTopic"`
}

func (NotificationConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationConfig)(nil)).Elem()
}

func (i NotificationConfigArgs) ToNotificationConfigOutput() NotificationConfigOutput {
	return i.ToNotificationConfigOutputWithContext(context.Background())
}

func (i NotificationConfigArgs) ToNotificationConfigOutputWithContext(ctx context.Context) NotificationConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationConfigOutput)
}

func (i NotificationConfigArgs) ToNotificationConfigPtrOutput() NotificationConfigPtrOutput {
	return i.ToNotificationConfigPtrOutputWithContext(context.Background())
}

func (i NotificationConfigArgs) ToNotificationConfigPtrOutputWithContext(ctx context.Context) NotificationConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationConfigOutput).ToNotificationConfigPtrOutputWithContext(ctx)
}

// NotificationConfigPtrInput is an input type that accepts NotificationConfigArgs, NotificationConfigPtr and NotificationConfigPtrOutput values.
// You can construct a concrete instance of `NotificationConfigPtrInput` via:
//
//          NotificationConfigArgs{...}
//
//  or:
//
//          nil
type NotificationConfigPtrInput interface {
	pulumi.Input

	ToNotificationConfigPtrOutput() NotificationConfigPtrOutput
	ToNotificationConfigPtrOutputWithContext(context.Context) NotificationConfigPtrOutput
}

type notificationConfigPtrType NotificationConfigArgs

func NotificationConfigPtr(v *NotificationConfigArgs) NotificationConfigPtrInput {
	return (*notificationConfigPtrType)(v)
}

func (*notificationConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationConfig)(nil)).Elem()
}

func (i *notificationConfigPtrType) ToNotificationConfigPtrOutput() NotificationConfigPtrOutput {
	return i.ToNotificationConfigPtrOutputWithContext(context.Background())
}

func (i *notificationConfigPtrType) ToNotificationConfigPtrOutputWithContext(ctx context.Context) NotificationConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationConfigPtrOutput)
}

// Specifies where to send notifications upon changes to a data store.
type NotificationConfigOutput struct{ *pulumi.OutputState }

func (NotificationConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationConfig)(nil)).Elem()
}

func (o NotificationConfigOutput) ToNotificationConfigOutput() NotificationConfigOutput {
	return o
}

func (o NotificationConfigOutput) ToNotificationConfigOutputWithContext(ctx context.Context) NotificationConfigOutput {
	return o
}

func (o NotificationConfigOutput) ToNotificationConfigPtrOutput() NotificationConfigPtrOutput {
	return o.ToNotificationConfigPtrOutputWithContext(context.Background())
}

func (o NotificationConfigOutput) ToNotificationConfigPtrOutputWithContext(ctx context.Context) NotificationConfigPtrOutput {
	return o.ApplyT(func(v NotificationConfig) *NotificationConfig {
		return &v
	}).(NotificationConfigPtrOutput)
}

// The [Cloud Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Cloud Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Cloud Pub/Sub, errors are logged to Cloud Logging (see [Viewing logs](/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
func (o NotificationConfigOutput) PubsubTopic() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NotificationConfig) *string { return v.PubsubTopic }).(pulumi.StringPtrOutput)
}

type NotificationConfigPtrOutput struct{ *pulumi.OutputState }

func (NotificationConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationConfig)(nil)).Elem()
}

func (o NotificationConfigPtrOutput) ToNotificationConfigPtrOutput() NotificationConfigPtrOutput {
	return o
}

func (o NotificationConfigPtrOutput) ToNotificationConfigPtrOutputWithContext(ctx context.Context) NotificationConfigPtrOutput {
	return o
}

func (o NotificationConfigPtrOutput) Elem() NotificationConfigOutput {
	return o.ApplyT(func(v *NotificationConfig) NotificationConfig { return *v }).(NotificationConfigOutput)
}

// The [Cloud Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Cloud Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Cloud Pub/Sub, errors are logged to Cloud Logging (see [Viewing logs](/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
func (o NotificationConfigPtrOutput) PubsubTopic() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NotificationConfig) *string {
		if v == nil {
			return nil
		}
		return v.PubsubTopic
	}).(pulumi.StringPtrOutput)
}

// The content of a HL7v2 message in a structured format.
type ParsedData struct {
	Segments []Segment `pulumi:"segments"`
}

// ParsedDataInput is an input type that accepts ParsedDataArgs and ParsedDataOutput values.
// You can construct a concrete instance of `ParsedDataInput` via:
//
//          ParsedDataArgs{...}
type ParsedDataInput interface {
	pulumi.Input

	ToParsedDataOutput() ParsedDataOutput
	ToParsedDataOutputWithContext(context.Context) ParsedDataOutput
}

// The content of a HL7v2 message in a structured format.
type ParsedDataArgs struct {
	Segments SegmentArrayInput `pulumi:"segments"`
}

func (ParsedDataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ParsedData)(nil)).Elem()
}

func (i ParsedDataArgs) ToParsedDataOutput() ParsedDataOutput {
	return i.ToParsedDataOutputWithContext(context.Background())
}

func (i ParsedDataArgs) ToParsedDataOutputWithContext(ctx context.Context) ParsedDataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParsedDataOutput)
}

func (i ParsedDataArgs) ToParsedDataPtrOutput() ParsedDataPtrOutput {
	return i.ToParsedDataPtrOutputWithContext(context.Background())
}

func (i ParsedDataArgs) ToParsedDataPtrOutputWithContext(ctx context.Context) ParsedDataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParsedDataOutput).ToParsedDataPtrOutputWithContext(ctx)
}

// ParsedDataPtrInput is an input type that accepts ParsedDataArgs, ParsedDataPtr and ParsedDataPtrOutput values.
// You can construct a concrete instance of `ParsedDataPtrInput` via:
//
//          ParsedDataArgs{...}
//
//  or:
//
//          nil
type ParsedDataPtrInput interface {
	pulumi.Input

	ToParsedDataPtrOutput() ParsedDataPtrOutput
	ToParsedDataPtrOutputWithContext(context.Context) ParsedDataPtrOutput
}

type parsedDataPtrType ParsedDataArgs

func ParsedDataPtr(v *ParsedDataArgs) ParsedDataPtrInput {
	return (*parsedDataPtrType)(v)
}

func (*parsedDataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ParsedData)(nil)).Elem()
}

func (i *parsedDataPtrType) ToParsedDataPtrOutput() ParsedDataPtrOutput {
	return i.ToParsedDataPtrOutputWithContext(context.Background())
}

func (i *parsedDataPtrType) ToParsedDataPtrOutputWithContext(ctx context.Context) ParsedDataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParsedDataPtrOutput)
}

// The content of a HL7v2 message in a structured format.
type ParsedDataOutput struct{ *pulumi.OutputState }

func (ParsedDataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ParsedData)(nil)).Elem()
}

func (o ParsedDataOutput) ToParsedDataOutput() ParsedDataOutput {
	return o
}

func (o ParsedDataOutput) ToParsedDataOutputWithContext(ctx context.Context) ParsedDataOutput {
	return o
}

func (o ParsedDataOutput) ToParsedDataPtrOutput() ParsedDataPtrOutput {
	return o.ToParsedDataPtrOutputWithContext(context.Background())
}

func (o ParsedDataOutput) ToParsedDataPtrOutputWithContext(ctx context.Context) ParsedDataPtrOutput {
	return o.ApplyT(func(v ParsedData) *ParsedData {
		return &v
	}).(ParsedDataPtrOutput)
}
func (o ParsedDataOutput) Segments() SegmentArrayOutput {
	return o.ApplyT(func(v ParsedData) []Segment { return v.Segments }).(SegmentArrayOutput)
}

type ParsedDataPtrOutput struct{ *pulumi.OutputState }

func (ParsedDataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ParsedData)(nil)).Elem()
}

func (o ParsedDataPtrOutput) ToParsedDataPtrOutput() ParsedDataPtrOutput {
	return o
}

func (o ParsedDataPtrOutput) ToParsedDataPtrOutputWithContext(ctx context.Context) ParsedDataPtrOutput {
	return o
}

func (o ParsedDataPtrOutput) Elem() ParsedDataOutput {
	return o.ApplyT(func(v *ParsedData) ParsedData { return *v }).(ParsedDataOutput)
}

func (o ParsedDataPtrOutput) Segments() SegmentArrayOutput {
	return o.ApplyT(func(v *ParsedData) []Segment {
		if v == nil {
			return nil
		}
		return v.Segments
	}).(SegmentArrayOutput)
}

// The configuration for the parser. It determines how the server parses the messages.
type ParserConfig struct {
	// Determines whether messages with no header are allowed.
	AllowNullHeader *bool `pulumi:"allowNullHeader"`
	// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator.
	SegmentTerminator *string `pulumi:"segmentTerminator"`
}

// ParserConfigInput is an input type that accepts ParserConfigArgs and ParserConfigOutput values.
// You can construct a concrete instance of `ParserConfigInput` via:
//
//          ParserConfigArgs{...}
type ParserConfigInput interface {
	pulumi.Input

	ToParserConfigOutput() ParserConfigOutput
	ToParserConfigOutputWithContext(context.Context) ParserConfigOutput
}

// The configuration for the parser. It determines how the server parses the messages.
type ParserConfigArgs struct {
	// Determines whether messages with no header are allowed.
	AllowNullHeader pulumi.BoolPtrInput `pulumi:"allowNullHeader"`
	// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator.
	SegmentTerminator pulumi.StringPtrInput `pulumi:"segmentTerminator"`
}

func (ParserConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ParserConfig)(nil)).Elem()
}

func (i ParserConfigArgs) ToParserConfigOutput() ParserConfigOutput {
	return i.ToParserConfigOutputWithContext(context.Background())
}

func (i ParserConfigArgs) ToParserConfigOutputWithContext(ctx context.Context) ParserConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParserConfigOutput)
}

func (i ParserConfigArgs) ToParserConfigPtrOutput() ParserConfigPtrOutput {
	return i.ToParserConfigPtrOutputWithContext(context.Background())
}

func (i ParserConfigArgs) ToParserConfigPtrOutputWithContext(ctx context.Context) ParserConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParserConfigOutput).ToParserConfigPtrOutputWithContext(ctx)
}

// ParserConfigPtrInput is an input type that accepts ParserConfigArgs, ParserConfigPtr and ParserConfigPtrOutput values.
// You can construct a concrete instance of `ParserConfigPtrInput` via:
//
//          ParserConfigArgs{...}
//
//  or:
//
//          nil
type ParserConfigPtrInput interface {
	pulumi.Input

	ToParserConfigPtrOutput() ParserConfigPtrOutput
	ToParserConfigPtrOutputWithContext(context.Context) ParserConfigPtrOutput
}

type parserConfigPtrType ParserConfigArgs

func ParserConfigPtr(v *ParserConfigArgs) ParserConfigPtrInput {
	return (*parserConfigPtrType)(v)
}

func (*parserConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ParserConfig)(nil)).Elem()
}

func (i *parserConfigPtrType) ToParserConfigPtrOutput() ParserConfigPtrOutput {
	return i.ToParserConfigPtrOutputWithContext(context.Background())
}

func (i *parserConfigPtrType) ToParserConfigPtrOutputWithContext(ctx context.Context) ParserConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParserConfigPtrOutput)
}

// The configuration for the parser. It determines how the server parses the messages.
type ParserConfigOutput struct{ *pulumi.OutputState }

func (ParserConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ParserConfig)(nil)).Elem()
}

func (o ParserConfigOutput) ToParserConfigOutput() ParserConfigOutput {
	return o
}

func (o ParserConfigOutput) ToParserConfigOutputWithContext(ctx context.Context) ParserConfigOutput {
	return o
}

func (o ParserConfigOutput) ToParserConfigPtrOutput() ParserConfigPtrOutput {
	return o.ToParserConfigPtrOutputWithContext(context.Background())
}

func (o ParserConfigOutput) ToParserConfigPtrOutputWithContext(ctx context.Context) ParserConfigPtrOutput {
	return o.ApplyT(func(v ParserConfig) *ParserConfig {
		return &v
	}).(ParserConfigPtrOutput)
}

// Determines whether messages with no header are allowed.
func (o ParserConfigOutput) AllowNullHeader() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ParserConfig) *bool { return v.AllowNullHeader }).(pulumi.BoolPtrOutput)
}

// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator.
func (o ParserConfigOutput) SegmentTerminator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ParserConfig) *string { return v.SegmentTerminator }).(pulumi.StringPtrOutput)
}

type ParserConfigPtrOutput struct{ *pulumi.OutputState }

func (ParserConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ParserConfig)(nil)).Elem()
}

func (o ParserConfigPtrOutput) ToParserConfigPtrOutput() ParserConfigPtrOutput {
	return o
}

func (o ParserConfigPtrOutput) ToParserConfigPtrOutputWithContext(ctx context.Context) ParserConfigPtrOutput {
	return o
}

func (o ParserConfigPtrOutput) Elem() ParserConfigOutput {
	return o.ApplyT(func(v *ParserConfig) ParserConfig { return *v }).(ParserConfigOutput)
}

// Determines whether messages with no header are allowed.
func (o ParserConfigPtrOutput) AllowNullHeader() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ParserConfig) *bool {
		if v == nil {
			return nil
		}
		return v.AllowNullHeader
	}).(pulumi.BoolPtrOutput)
}

// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator.
func (o ParserConfigPtrOutput) SegmentTerminator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ParserConfig) *string {
		if v == nil {
			return nil
		}
		return v.SegmentTerminator
	}).(pulumi.StringPtrOutput)
}

// A patient identifier and associated type.
type PatientId struct {
	// ID type. For example, MRN or NHS.
	Type *string `pulumi:"type"`
	// The patient's unique identifier.
	Value *string `pulumi:"value"`
}

// PatientIdInput is an input type that accepts PatientIdArgs and PatientIdOutput values.
// You can construct a concrete instance of `PatientIdInput` via:
//
//          PatientIdArgs{...}
type PatientIdInput interface {
	pulumi.Input

	ToPatientIdOutput() PatientIdOutput
	ToPatientIdOutputWithContext(context.Context) PatientIdOutput
}

// A patient identifier and associated type.
type PatientIdArgs struct {
	// ID type. For example, MRN or NHS.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// The patient's unique identifier.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (PatientIdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PatientId)(nil)).Elem()
}

func (i PatientIdArgs) ToPatientIdOutput() PatientIdOutput {
	return i.ToPatientIdOutputWithContext(context.Background())
}

func (i PatientIdArgs) ToPatientIdOutputWithContext(ctx context.Context) PatientIdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PatientIdOutput)
}

// PatientIdArrayInput is an input type that accepts PatientIdArray and PatientIdArrayOutput values.
// You can construct a concrete instance of `PatientIdArrayInput` via:
//
//          PatientIdArray{ PatientIdArgs{...} }
type PatientIdArrayInput interface {
	pulumi.Input

	ToPatientIdArrayOutput() PatientIdArrayOutput
	ToPatientIdArrayOutputWithContext(context.Context) PatientIdArrayOutput
}

type PatientIdArray []PatientIdInput

func (PatientIdArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PatientId)(nil)).Elem()
}

func (i PatientIdArray) ToPatientIdArrayOutput() PatientIdArrayOutput {
	return i.ToPatientIdArrayOutputWithContext(context.Background())
}

func (i PatientIdArray) ToPatientIdArrayOutputWithContext(ctx context.Context) PatientIdArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PatientIdArrayOutput)
}

// A patient identifier and associated type.
type PatientIdOutput struct{ *pulumi.OutputState }

func (PatientIdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PatientId)(nil)).Elem()
}

func (o PatientIdOutput) ToPatientIdOutput() PatientIdOutput {
	return o
}

func (o PatientIdOutput) ToPatientIdOutputWithContext(ctx context.Context) PatientIdOutput {
	return o
}

// ID type. For example, MRN or NHS.
func (o PatientIdOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PatientId) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// The patient's unique identifier.
func (o PatientIdOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PatientId) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type PatientIdArrayOutput struct{ *pulumi.OutputState }

func (PatientIdArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PatientId)(nil)).Elem()
}

func (o PatientIdArrayOutput) ToPatientIdArrayOutput() PatientIdArrayOutput {
	return o
}

func (o PatientIdArrayOutput) ToPatientIdArrayOutputWithContext(ctx context.Context) PatientIdArrayOutput {
	return o
}

func (o PatientIdArrayOutput) Index(i pulumi.IntInput) PatientIdOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PatientId {
		return vs[0].([]PatientId)[vs[1].(int)]
	}).(PatientIdOutput)
}

// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members` to a single `role`. Members can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') - etag: BwWWja0YfJA= - version: 3 For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
type PolicyType struct {
	// Specifies cloud audit logging configuration for this policy.
	AuditConfigs []AuditConfig `pulumi:"auditConfigs"`
	// Associates a list of `members` to a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one member.
	Bindings []Binding `pulumi:"bindings"`
	// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
	Etag *string `pulumi:"etag"`
	// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Version *int `pulumi:"version"`
}

// PolicyTypeInput is an input type that accepts PolicyTypeArgs and PolicyTypeOutput values.
// You can construct a concrete instance of `PolicyTypeInput` via:
//
//          PolicyTypeArgs{...}
type PolicyTypeInput interface {
	pulumi.Input

	ToPolicyTypeOutput() PolicyTypeOutput
	ToPolicyTypeOutputWithContext(context.Context) PolicyTypeOutput
}

// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members` to a single `role`. Members can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') - etag: BwWWja0YfJA= - version: 3 For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
type PolicyTypeArgs struct {
	// Specifies cloud audit logging configuration for this policy.
	AuditConfigs AuditConfigArrayInput `pulumi:"auditConfigs"`
	// Associates a list of `members` to a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one member.
	Bindings BindingArrayInput `pulumi:"bindings"`
	// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
	Etag pulumi.StringPtrInput `pulumi:"etag"`
	// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Version pulumi.IntPtrInput `pulumi:"version"`
}

func (PolicyTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PolicyType)(nil)).Elem()
}

func (i PolicyTypeArgs) ToPolicyTypeOutput() PolicyTypeOutput {
	return i.ToPolicyTypeOutputWithContext(context.Background())
}

func (i PolicyTypeArgs) ToPolicyTypeOutputWithContext(ctx context.Context) PolicyTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyTypeOutput)
}

func (i PolicyTypeArgs) ToPolicyTypePtrOutput() PolicyTypePtrOutput {
	return i.ToPolicyTypePtrOutputWithContext(context.Background())
}

func (i PolicyTypeArgs) ToPolicyTypePtrOutputWithContext(ctx context.Context) PolicyTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyTypeOutput).ToPolicyTypePtrOutputWithContext(ctx)
}

// PolicyTypePtrInput is an input type that accepts PolicyTypeArgs, PolicyTypePtr and PolicyTypePtrOutput values.
// You can construct a concrete instance of `PolicyTypePtrInput` via:
//
//          PolicyTypeArgs{...}
//
//  or:
//
//          nil
type PolicyTypePtrInput interface {
	pulumi.Input

	ToPolicyTypePtrOutput() PolicyTypePtrOutput
	ToPolicyTypePtrOutputWithContext(context.Context) PolicyTypePtrOutput
}

type policyTypePtrType PolicyTypeArgs

func PolicyTypePtr(v *PolicyTypeArgs) PolicyTypePtrInput {
	return (*policyTypePtrType)(v)
}

func (*policyTypePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PolicyType)(nil)).Elem()
}

func (i *policyTypePtrType) ToPolicyTypePtrOutput() PolicyTypePtrOutput {
	return i.ToPolicyTypePtrOutputWithContext(context.Background())
}

func (i *policyTypePtrType) ToPolicyTypePtrOutputWithContext(ctx context.Context) PolicyTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyTypePtrOutput)
}

// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members` to a single `role`. Members can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') - etag: BwWWja0YfJA= - version: 3 For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
type PolicyTypeOutput struct{ *pulumi.OutputState }

func (PolicyTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PolicyType)(nil)).Elem()
}

func (o PolicyTypeOutput) ToPolicyTypeOutput() PolicyTypeOutput {
	return o
}

func (o PolicyTypeOutput) ToPolicyTypeOutputWithContext(ctx context.Context) PolicyTypeOutput {
	return o
}

func (o PolicyTypeOutput) ToPolicyTypePtrOutput() PolicyTypePtrOutput {
	return o.ToPolicyTypePtrOutputWithContext(context.Background())
}

func (o PolicyTypeOutput) ToPolicyTypePtrOutputWithContext(ctx context.Context) PolicyTypePtrOutput {
	return o.ApplyT(func(v PolicyType) *PolicyType {
		return &v
	}).(PolicyTypePtrOutput)
}

// Specifies cloud audit logging configuration for this policy.
func (o PolicyTypeOutput) AuditConfigs() AuditConfigArrayOutput {
	return o.ApplyT(func(v PolicyType) []AuditConfig { return v.AuditConfigs }).(AuditConfigArrayOutput)
}

// Associates a list of `members` to a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one member.
func (o PolicyTypeOutput) Bindings() BindingArrayOutput {
	return o.ApplyT(func(v PolicyType) []Binding { return v.Bindings }).(BindingArrayOutput)
}

// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
func (o PolicyTypeOutput) Etag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PolicyType) *string { return v.Etag }).(pulumi.StringPtrOutput)
}

// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o PolicyTypeOutput) Version() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PolicyType) *int { return v.Version }).(pulumi.IntPtrOutput)
}

type PolicyTypePtrOutput struct{ *pulumi.OutputState }

func (PolicyTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PolicyType)(nil)).Elem()
}

func (o PolicyTypePtrOutput) ToPolicyTypePtrOutput() PolicyTypePtrOutput {
	return o
}

func (o PolicyTypePtrOutput) ToPolicyTypePtrOutputWithContext(ctx context.Context) PolicyTypePtrOutput {
	return o
}

func (o PolicyTypePtrOutput) Elem() PolicyTypeOutput {
	return o.ApplyT(func(v *PolicyType) PolicyType { return *v }).(PolicyTypeOutput)
}

// Specifies cloud audit logging configuration for this policy.
func (o PolicyTypePtrOutput) AuditConfigs() AuditConfigArrayOutput {
	return o.ApplyT(func(v *PolicyType) []AuditConfig {
		if v == nil {
			return nil
		}
		return v.AuditConfigs
	}).(AuditConfigArrayOutput)
}

// Associates a list of `members` to a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one member.
func (o PolicyTypePtrOutput) Bindings() BindingArrayOutput {
	return o.ApplyT(func(v *PolicyType) []Binding {
		if v == nil {
			return nil
		}
		return v.Bindings
	}).(BindingArrayOutput)
}

// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
func (o PolicyTypePtrOutput) Etag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PolicyType) *string {
		if v == nil {
			return nil
		}
		return v.Etag
	}).(pulumi.StringPtrOutput)
}

// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o PolicyTypePtrOutput) Version() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PolicyType) *int {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.IntPtrOutput)
}

// Configuration for the FHIR BigQuery schema. Determines how the server generates the schema.
type SchemaConfig struct {
	// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
	RecursiveStructureDepth *string `pulumi:"recursiveStructureDepth"`
	// Specifies the output schema type. Schema type is required.
	SchemaType *string `pulumi:"schemaType"`
}

// SchemaConfigInput is an input type that accepts SchemaConfigArgs and SchemaConfigOutput values.
// You can construct a concrete instance of `SchemaConfigInput` via:
//
//          SchemaConfigArgs{...}
type SchemaConfigInput interface {
	pulumi.Input

	ToSchemaConfigOutput() SchemaConfigOutput
	ToSchemaConfigOutputWithContext(context.Context) SchemaConfigOutput
}

// Configuration for the FHIR BigQuery schema. Determines how the server generates the schema.
type SchemaConfigArgs struct {
	// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
	RecursiveStructureDepth pulumi.StringPtrInput `pulumi:"recursiveStructureDepth"`
	// Specifies the output schema type. Schema type is required.
	SchemaType pulumi.StringPtrInput `pulumi:"schemaType"`
}

func (SchemaConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaConfig)(nil)).Elem()
}

func (i SchemaConfigArgs) ToSchemaConfigOutput() SchemaConfigOutput {
	return i.ToSchemaConfigOutputWithContext(context.Background())
}

func (i SchemaConfigArgs) ToSchemaConfigOutputWithContext(ctx context.Context) SchemaConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaConfigOutput)
}

func (i SchemaConfigArgs) ToSchemaConfigPtrOutput() SchemaConfigPtrOutput {
	return i.ToSchemaConfigPtrOutputWithContext(context.Background())
}

func (i SchemaConfigArgs) ToSchemaConfigPtrOutputWithContext(ctx context.Context) SchemaConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaConfigOutput).ToSchemaConfigPtrOutputWithContext(ctx)
}

// SchemaConfigPtrInput is an input type that accepts SchemaConfigArgs, SchemaConfigPtr and SchemaConfigPtrOutput values.
// You can construct a concrete instance of `SchemaConfigPtrInput` via:
//
//          SchemaConfigArgs{...}
//
//  or:
//
//          nil
type SchemaConfigPtrInput interface {
	pulumi.Input

	ToSchemaConfigPtrOutput() SchemaConfigPtrOutput
	ToSchemaConfigPtrOutputWithContext(context.Context) SchemaConfigPtrOutput
}

type schemaConfigPtrType SchemaConfigArgs

func SchemaConfigPtr(v *SchemaConfigArgs) SchemaConfigPtrInput {
	return (*schemaConfigPtrType)(v)
}

func (*schemaConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaConfig)(nil)).Elem()
}

func (i *schemaConfigPtrType) ToSchemaConfigPtrOutput() SchemaConfigPtrOutput {
	return i.ToSchemaConfigPtrOutputWithContext(context.Background())
}

func (i *schemaConfigPtrType) ToSchemaConfigPtrOutputWithContext(ctx context.Context) SchemaConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaConfigPtrOutput)
}

// Configuration for the FHIR BigQuery schema. Determines how the server generates the schema.
type SchemaConfigOutput struct{ *pulumi.OutputState }

func (SchemaConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaConfig)(nil)).Elem()
}

func (o SchemaConfigOutput) ToSchemaConfigOutput() SchemaConfigOutput {
	return o
}

func (o SchemaConfigOutput) ToSchemaConfigOutputWithContext(ctx context.Context) SchemaConfigOutput {
	return o
}

func (o SchemaConfigOutput) ToSchemaConfigPtrOutput() SchemaConfigPtrOutput {
	return o.ToSchemaConfigPtrOutputWithContext(context.Background())
}

func (o SchemaConfigOutput) ToSchemaConfigPtrOutputWithContext(ctx context.Context) SchemaConfigPtrOutput {
	return o.ApplyT(func(v SchemaConfig) *SchemaConfig {
		return &v
	}).(SchemaConfigPtrOutput)
}

// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
func (o SchemaConfigOutput) RecursiveStructureDepth() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SchemaConfig) *string { return v.RecursiveStructureDepth }).(pulumi.StringPtrOutput)
}

// Specifies the output schema type. Schema type is required.
func (o SchemaConfigOutput) SchemaType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SchemaConfig) *string { return v.SchemaType }).(pulumi.StringPtrOutput)
}

type SchemaConfigPtrOutput struct{ *pulumi.OutputState }

func (SchemaConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaConfig)(nil)).Elem()
}

func (o SchemaConfigPtrOutput) ToSchemaConfigPtrOutput() SchemaConfigPtrOutput {
	return o
}

func (o SchemaConfigPtrOutput) ToSchemaConfigPtrOutputWithContext(ctx context.Context) SchemaConfigPtrOutput {
	return o
}

func (o SchemaConfigPtrOutput) Elem() SchemaConfigOutput {
	return o.ApplyT(func(v *SchemaConfig) SchemaConfig { return *v }).(SchemaConfigOutput)
}

// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
func (o SchemaConfigPtrOutput) RecursiveStructureDepth() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchemaConfig) *string {
		if v == nil {
			return nil
		}
		return v.RecursiveStructureDepth
	}).(pulumi.StringPtrOutput)
}

// Specifies the output schema type. Schema type is required.
func (o SchemaConfigPtrOutput) SchemaType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchemaConfig) *string {
		if v == nil {
			return nil
		}
		return v.SchemaType
	}).(pulumi.StringPtrOutput)
}

// A segment in a structured format.
type Segment struct {
	// A mapping from the positional location to the value. The key string uses zero-based indexes separated by dots to identify Fields, components and sub-components. A bracket notation is also used to identify different instances of a repeated field. Regex for key: (\d+)(\[\d+\])?(.\d+)?(.\d+)? Examples of (key, value) pairs: * (0.1, "hemoglobin") denotes that the first component of Field 0 has the value "hemoglobin". * (1.1.2, "CBC") denotes that the second sub-component of the first component of Field 1 has the value "CBC". * (1[0].1, "HbA1c") denotes that the first component of the first Instance of Field 1, which is repeated, has the value "HbA1c".
	Fields map[string]string `pulumi:"fields"`
	// A string that indicates the type of segment. For example, EVN or PID.
	SegmentId *string `pulumi:"segmentId"`
	// Set ID for segments that can be in a set. This can be empty if it's missing or isn't applicable.
	SetId *string `pulumi:"setId"`
}

// SegmentInput is an input type that accepts SegmentArgs and SegmentOutput values.
// You can construct a concrete instance of `SegmentInput` via:
//
//          SegmentArgs{...}
type SegmentInput interface {
	pulumi.Input

	ToSegmentOutput() SegmentOutput
	ToSegmentOutputWithContext(context.Context) SegmentOutput
}

// A segment in a structured format.
type SegmentArgs struct {
	// A mapping from the positional location to the value. The key string uses zero-based indexes separated by dots to identify Fields, components and sub-components. A bracket notation is also used to identify different instances of a repeated field. Regex for key: (\d+)(\[\d+\])?(.\d+)?(.\d+)? Examples of (key, value) pairs: * (0.1, "hemoglobin") denotes that the first component of Field 0 has the value "hemoglobin". * (1.1.2, "CBC") denotes that the second sub-component of the first component of Field 1 has the value "CBC". * (1[0].1, "HbA1c") denotes that the first component of the first Instance of Field 1, which is repeated, has the value "HbA1c".
	Fields pulumi.StringMapInput `pulumi:"fields"`
	// A string that indicates the type of segment. For example, EVN or PID.
	SegmentId pulumi.StringPtrInput `pulumi:"segmentId"`
	// Set ID for segments that can be in a set. This can be empty if it's missing or isn't applicable.
	SetId pulumi.StringPtrInput `pulumi:"setId"`
}

func (SegmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Segment)(nil)).Elem()
}

func (i SegmentArgs) ToSegmentOutput() SegmentOutput {
	return i.ToSegmentOutputWithContext(context.Background())
}

func (i SegmentArgs) ToSegmentOutputWithContext(ctx context.Context) SegmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SegmentOutput)
}

// SegmentArrayInput is an input type that accepts SegmentArray and SegmentArrayOutput values.
// You can construct a concrete instance of `SegmentArrayInput` via:
//
//          SegmentArray{ SegmentArgs{...} }
type SegmentArrayInput interface {
	pulumi.Input

	ToSegmentArrayOutput() SegmentArrayOutput
	ToSegmentArrayOutputWithContext(context.Context) SegmentArrayOutput
}

type SegmentArray []SegmentInput

func (SegmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Segment)(nil)).Elem()
}

func (i SegmentArray) ToSegmentArrayOutput() SegmentArrayOutput {
	return i.ToSegmentArrayOutputWithContext(context.Background())
}

func (i SegmentArray) ToSegmentArrayOutputWithContext(ctx context.Context) SegmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SegmentArrayOutput)
}

// A segment in a structured format.
type SegmentOutput struct{ *pulumi.OutputState }

func (SegmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Segment)(nil)).Elem()
}

func (o SegmentOutput) ToSegmentOutput() SegmentOutput {
	return o
}

func (o SegmentOutput) ToSegmentOutputWithContext(ctx context.Context) SegmentOutput {
	return o
}

// A mapping from the positional location to the value. The key string uses zero-based indexes separated by dots to identify Fields, components and sub-components. A bracket notation is also used to identify different instances of a repeated field. Regex for key: (\d+)(\[\d+\])?(.\d+)?(.\d+)? Examples of (key, value) pairs: * (0.1, "hemoglobin") denotes that the first component of Field 0 has the value "hemoglobin". * (1.1.2, "CBC") denotes that the second sub-component of the first component of Field 1 has the value "CBC". * (1[0].1, "HbA1c") denotes that the first component of the first Instance of Field 1, which is repeated, has the value "HbA1c".
func (o SegmentOutput) Fields() pulumi.StringMapOutput {
	return o.ApplyT(func(v Segment) map[string]string { return v.Fields }).(pulumi.StringMapOutput)
}

// A string that indicates the type of segment. For example, EVN or PID.
func (o SegmentOutput) SegmentId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Segment) *string { return v.SegmentId }).(pulumi.StringPtrOutput)
}

// Set ID for segments that can be in a set. This can be empty if it's missing or isn't applicable.
func (o SegmentOutput) SetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Segment) *string { return v.SetId }).(pulumi.StringPtrOutput)
}

type SegmentArrayOutput struct{ *pulumi.OutputState }

func (SegmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Segment)(nil)).Elem()
}

func (o SegmentArrayOutput) ToSegmentArrayOutput() SegmentArrayOutput {
	return o
}

func (o SegmentArrayOutput) ToSegmentArrayOutputWithContext(ctx context.Context) SegmentArrayOutput {
	return o
}

func (o SegmentArrayOutput) Index(i pulumi.IntInput) SegmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Segment {
		return vs[0].([]Segment)[vs[1].(int)]
	}).(SegmentOutput)
}

// Contains configuration for streaming FHIR export.
type StreamConfig struct {
	// The destination BigQuery structure that contains both the dataset location and corresponding schema config. The output is organized in one table per resource type. The server reuses the existing tables (if any) that are named after the resource types. For example, "Patient", "Observation". When there is no existing table for a given resource type, the server attempts to create one. When a table schema doesn't align with the schema config, either because of existing incompatible schema or out of band incompatible modification, the server does not stream in new data. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any resource mutation that generates more than 1 MB of BigQuery data is not streamed. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. Results are appended to the corresponding BigQuery tables. Different versions of the same resource are distinguishable by the meta.versionId and meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results in the new version is recorded in the meta.tag. The tables contain all historical resource versions since streaming was enabled. For query convenience, the server also creates one view per table of the same name containing only the current resource version. The streamed data in the BigQuery dataset is not guaranteed to be completely unique. The combination of the id and meta.versionId columns should ideally identify a single unique row. But in rare cases, duplicates may exist. At query time, users may use the SQL select statement to keep only one of the duplicate rows given an id and meta.versionId pair. Alternatively, the server created view mentioned above also filters out duplicates. If a resource mutation cannot be streamed to BigQuery, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](/healthcare/docs/how-tos/logging)).
	BigqueryDestination *GoogleCloudHealthcareV1FhirBigQueryDestination `pulumi:"bigqueryDestination"`
	// Supply a FHIR resource type (such as "Patient" or "Observation"). See https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats an empty list as an intent to stream all the supported resource types in this FHIR store.
	ResourceTypes []string `pulumi:"resourceTypes"`
}

// StreamConfigInput is an input type that accepts StreamConfigArgs and StreamConfigOutput values.
// You can construct a concrete instance of `StreamConfigInput` via:
//
//          StreamConfigArgs{...}
type StreamConfigInput interface {
	pulumi.Input

	ToStreamConfigOutput() StreamConfigOutput
	ToStreamConfigOutputWithContext(context.Context) StreamConfigOutput
}

// Contains configuration for streaming FHIR export.
type StreamConfigArgs struct {
	// The destination BigQuery structure that contains both the dataset location and corresponding schema config. The output is organized in one table per resource type. The server reuses the existing tables (if any) that are named after the resource types. For example, "Patient", "Observation". When there is no existing table for a given resource type, the server attempts to create one. When a table schema doesn't align with the schema config, either because of existing incompatible schema or out of band incompatible modification, the server does not stream in new data. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any resource mutation that generates more than 1 MB of BigQuery data is not streamed. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. Results are appended to the corresponding BigQuery tables. Different versions of the same resource are distinguishable by the meta.versionId and meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results in the new version is recorded in the meta.tag. The tables contain all historical resource versions since streaming was enabled. For query convenience, the server also creates one view per table of the same name containing only the current resource version. The streamed data in the BigQuery dataset is not guaranteed to be completely unique. The combination of the id and meta.versionId columns should ideally identify a single unique row. But in rare cases, duplicates may exist. At query time, users may use the SQL select statement to keep only one of the duplicate rows given an id and meta.versionId pair. Alternatively, the server created view mentioned above also filters out duplicates. If a resource mutation cannot be streamed to BigQuery, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](/healthcare/docs/how-tos/logging)).
	BigqueryDestination GoogleCloudHealthcareV1FhirBigQueryDestinationPtrInput `pulumi:"bigqueryDestination"`
	// Supply a FHIR resource type (such as "Patient" or "Observation"). See https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats an empty list as an intent to stream all the supported resource types in this FHIR store.
	ResourceTypes pulumi.StringArrayInput `pulumi:"resourceTypes"`
}

func (StreamConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamConfig)(nil)).Elem()
}

func (i StreamConfigArgs) ToStreamConfigOutput() StreamConfigOutput {
	return i.ToStreamConfigOutputWithContext(context.Background())
}

func (i StreamConfigArgs) ToStreamConfigOutputWithContext(ctx context.Context) StreamConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamConfigOutput)
}

// StreamConfigArrayInput is an input type that accepts StreamConfigArray and StreamConfigArrayOutput values.
// You can construct a concrete instance of `StreamConfigArrayInput` via:
//
//          StreamConfigArray{ StreamConfigArgs{...} }
type StreamConfigArrayInput interface {
	pulumi.Input

	ToStreamConfigArrayOutput() StreamConfigArrayOutput
	ToStreamConfigArrayOutputWithContext(context.Context) StreamConfigArrayOutput
}

type StreamConfigArray []StreamConfigInput

func (StreamConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamConfig)(nil)).Elem()
}

func (i StreamConfigArray) ToStreamConfigArrayOutput() StreamConfigArrayOutput {
	return i.ToStreamConfigArrayOutputWithContext(context.Background())
}

func (i StreamConfigArray) ToStreamConfigArrayOutputWithContext(ctx context.Context) StreamConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamConfigArrayOutput)
}

// Contains configuration for streaming FHIR export.
type StreamConfigOutput struct{ *pulumi.OutputState }

func (StreamConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamConfig)(nil)).Elem()
}

func (o StreamConfigOutput) ToStreamConfigOutput() StreamConfigOutput {
	return o
}

func (o StreamConfigOutput) ToStreamConfigOutputWithContext(ctx context.Context) StreamConfigOutput {
	return o
}

// The destination BigQuery structure that contains both the dataset location and corresponding schema config. The output is organized in one table per resource type. The server reuses the existing tables (if any) that are named after the resource types. For example, "Patient", "Observation". When there is no existing table for a given resource type, the server attempts to create one. When a table schema doesn't align with the schema config, either because of existing incompatible schema or out of band incompatible modification, the server does not stream in new data. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any resource mutation that generates more than 1 MB of BigQuery data is not streamed. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. Results are appended to the corresponding BigQuery tables. Different versions of the same resource are distinguishable by the meta.versionId and meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results in the new version is recorded in the meta.tag. The tables contain all historical resource versions since streaming was enabled. For query convenience, the server also creates one view per table of the same name containing only the current resource version. The streamed data in the BigQuery dataset is not guaranteed to be completely unique. The combination of the id and meta.versionId columns should ideally identify a single unique row. But in rare cases, duplicates may exist. At query time, users may use the SQL select statement to keep only one of the duplicate rows given an id and meta.versionId pair. Alternatively, the server created view mentioned above also filters out duplicates. If a resource mutation cannot be streamed to BigQuery, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](/healthcare/docs/how-tos/logging)).
func (o StreamConfigOutput) BigqueryDestination() GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput {
	return o.ApplyT(func(v StreamConfig) *GoogleCloudHealthcareV1FhirBigQueryDestination { return v.BigqueryDestination }).(GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput)
}

// Supply a FHIR resource type (such as "Patient" or "Observation"). See https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats an empty list as an intent to stream all the supported resource types in this FHIR store.
func (o StreamConfigOutput) ResourceTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v StreamConfig) []string { return v.ResourceTypes }).(pulumi.StringArrayOutput)
}

type StreamConfigArrayOutput struct{ *pulumi.OutputState }

func (StreamConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamConfig)(nil)).Elem()
}

func (o StreamConfigArrayOutput) ToStreamConfigArrayOutput() StreamConfigArrayOutput {
	return o
}

func (o StreamConfigArrayOutput) ToStreamConfigArrayOutputWithContext(ctx context.Context) StreamConfigArrayOutput {
	return o
}

func (o StreamConfigArrayOutput) Index(i pulumi.IntInput) StreamConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamConfig {
		return vs[0].([]StreamConfig)[vs[1].(int)]
	}).(StreamConfigOutput)
}

func init() {
	pulumi.RegisterOutputType(AuditConfigOutput{})
	pulumi.RegisterOutputType(AuditConfigArrayOutput{})
	pulumi.RegisterOutputType(AuditLogConfigOutput{})
	pulumi.RegisterOutputType(AuditLogConfigArrayOutput{})
	pulumi.RegisterOutputType(BindingOutput{})
	pulumi.RegisterOutputType(BindingArrayOutput{})
	pulumi.RegisterOutputType(ExprOutput{})
	pulumi.RegisterOutputType(ExprPtrOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1FhirBigQueryDestinationOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1FhirBigQueryDestinationPtrOutput{})
	pulumi.RegisterOutputType(Hl7V2NotificationConfigOutput{})
	pulumi.RegisterOutputType(Hl7V2NotificationConfigArrayOutput{})
	pulumi.RegisterOutputType(MessageTypeOutput{})
	pulumi.RegisterOutputType(MessageTypePtrOutput{})
	pulumi.RegisterOutputType(NotificationConfigOutput{})
	pulumi.RegisterOutputType(NotificationConfigPtrOutput{})
	pulumi.RegisterOutputType(ParsedDataOutput{})
	pulumi.RegisterOutputType(ParsedDataPtrOutput{})
	pulumi.RegisterOutputType(ParserConfigOutput{})
	pulumi.RegisterOutputType(ParserConfigPtrOutput{})
	pulumi.RegisterOutputType(PatientIdOutput{})
	pulumi.RegisterOutputType(PatientIdArrayOutput{})
	pulumi.RegisterOutputType(PolicyTypeOutput{})
	pulumi.RegisterOutputType(PolicyTypePtrOutput{})
	pulumi.RegisterOutputType(SchemaConfigOutput{})
	pulumi.RegisterOutputType(SchemaConfigPtrOutput{})
	pulumi.RegisterOutputType(SegmentOutput{})
	pulumi.RegisterOutputType(SegmentArrayOutput{})
	pulumi.RegisterOutputType(StreamConfigOutput{})
	pulumi.RegisterOutputType(StreamConfigArrayOutput{})
}
