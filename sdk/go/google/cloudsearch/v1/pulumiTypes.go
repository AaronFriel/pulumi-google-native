// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

type CompositeFilter struct {
	// The logic operator of the sub filter.
	LogicOperator *string `pulumi:"logicOperator"`
	// Sub filters.
	SubFilters []Filter `pulumi:"subFilters"`
}

// CompositeFilterInput is an input type that accepts CompositeFilterArgs and CompositeFilterOutput values.
// You can construct a concrete instance of `CompositeFilterInput` via:
//
//          CompositeFilterArgs{...}
type CompositeFilterInput interface {
	pulumi.Input

	ToCompositeFilterOutput() CompositeFilterOutput
	ToCompositeFilterOutputWithContext(context.Context) CompositeFilterOutput
}

type CompositeFilterArgs struct {
	// The logic operator of the sub filter.
	LogicOperator pulumi.StringPtrInput `pulumi:"logicOperator"`
	// Sub filters.
	SubFilters FilterArrayInput `pulumi:"subFilters"`
}

func (CompositeFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompositeFilter)(nil)).Elem()
}

func (i CompositeFilterArgs) ToCompositeFilterOutput() CompositeFilterOutput {
	return i.ToCompositeFilterOutputWithContext(context.Background())
}

func (i CompositeFilterArgs) ToCompositeFilterOutputWithContext(ctx context.Context) CompositeFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompositeFilterOutput)
}

func (i CompositeFilterArgs) ToCompositeFilterPtrOutput() CompositeFilterPtrOutput {
	return i.ToCompositeFilterPtrOutputWithContext(context.Background())
}

func (i CompositeFilterArgs) ToCompositeFilterPtrOutputWithContext(ctx context.Context) CompositeFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompositeFilterOutput).ToCompositeFilterPtrOutputWithContext(ctx)
}

// CompositeFilterPtrInput is an input type that accepts CompositeFilterArgs, CompositeFilterPtr and CompositeFilterPtrOutput values.
// You can construct a concrete instance of `CompositeFilterPtrInput` via:
//
//          CompositeFilterArgs{...}
//
//  or:
//
//          nil
type CompositeFilterPtrInput interface {
	pulumi.Input

	ToCompositeFilterPtrOutput() CompositeFilterPtrOutput
	ToCompositeFilterPtrOutputWithContext(context.Context) CompositeFilterPtrOutput
}

type compositeFilterPtrType CompositeFilterArgs

func CompositeFilterPtr(v *CompositeFilterArgs) CompositeFilterPtrInput {
	return (*compositeFilterPtrType)(v)
}

func (*compositeFilterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompositeFilter)(nil)).Elem()
}

func (i *compositeFilterPtrType) ToCompositeFilterPtrOutput() CompositeFilterPtrOutput {
	return i.ToCompositeFilterPtrOutputWithContext(context.Background())
}

func (i *compositeFilterPtrType) ToCompositeFilterPtrOutputWithContext(ctx context.Context) CompositeFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompositeFilterPtrOutput)
}

type CompositeFilterOutput struct{ *pulumi.OutputState }

func (CompositeFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompositeFilter)(nil)).Elem()
}

func (o CompositeFilterOutput) ToCompositeFilterOutput() CompositeFilterOutput {
	return o
}

func (o CompositeFilterOutput) ToCompositeFilterOutputWithContext(ctx context.Context) CompositeFilterOutput {
	return o
}

func (o CompositeFilterOutput) ToCompositeFilterPtrOutput() CompositeFilterPtrOutput {
	return o.ToCompositeFilterPtrOutputWithContext(context.Background())
}

func (o CompositeFilterOutput) ToCompositeFilterPtrOutputWithContext(ctx context.Context) CompositeFilterPtrOutput {
	return o.ApplyT(func(v CompositeFilter) *CompositeFilter {
		return &v
	}).(CompositeFilterPtrOutput)
}

// The logic operator of the sub filter.
func (o CompositeFilterOutput) LogicOperator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompositeFilter) *string { return v.LogicOperator }).(pulumi.StringPtrOutput)
}

// Sub filters.
func (o CompositeFilterOutput) SubFilters() FilterArrayOutput {
	return o.ApplyT(func(v CompositeFilter) []Filter { return v.SubFilters }).(FilterArrayOutput)
}

type CompositeFilterPtrOutput struct{ *pulumi.OutputState }

func (CompositeFilterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompositeFilter)(nil)).Elem()
}

func (o CompositeFilterPtrOutput) ToCompositeFilterPtrOutput() CompositeFilterPtrOutput {
	return o
}

func (o CompositeFilterPtrOutput) ToCompositeFilterPtrOutputWithContext(ctx context.Context) CompositeFilterPtrOutput {
	return o
}

func (o CompositeFilterPtrOutput) Elem() CompositeFilterOutput {
	return o.ApplyT(func(v *CompositeFilter) CompositeFilter { return *v }).(CompositeFilterOutput)
}

// The logic operator of the sub filter.
func (o CompositeFilterPtrOutput) LogicOperator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CompositeFilter) *string {
		if v == nil {
			return nil
		}
		return v.LogicOperator
	}).(pulumi.StringPtrOutput)
}

// Sub filters.
func (o CompositeFilterPtrOutput) SubFilters() FilterArrayOutput {
	return o.ApplyT(func(v *CompositeFilter) []Filter {
		if v == nil {
			return nil
		}
		return v.SubFilters
	}).(FilterArrayOutput)
}

// Restriction on Datasource.
type DataSourceRestriction struct {
	// Filter options restricting the results. If multiple filters are present, they are grouped by object type before joining. Filters with the same object type are joined conjunctively, then the resulting expressions are joined disjunctively. The maximum number of elements is 20. NOTE: Suggest API supports only few filters at the moment: "objecttype", "type" and "mimetype". For now, schema specific filters cannot be used to filter suggestions.
	FilterOptions []FilterOptions `pulumi:"filterOptions"`
	// The source of restriction.
	Source *Source `pulumi:"source"`
}

// DataSourceRestrictionInput is an input type that accepts DataSourceRestrictionArgs and DataSourceRestrictionOutput values.
// You can construct a concrete instance of `DataSourceRestrictionInput` via:
//
//          DataSourceRestrictionArgs{...}
type DataSourceRestrictionInput interface {
	pulumi.Input

	ToDataSourceRestrictionOutput() DataSourceRestrictionOutput
	ToDataSourceRestrictionOutputWithContext(context.Context) DataSourceRestrictionOutput
}

// Restriction on Datasource.
type DataSourceRestrictionArgs struct {
	// Filter options restricting the results. If multiple filters are present, they are grouped by object type before joining. Filters with the same object type are joined conjunctively, then the resulting expressions are joined disjunctively. The maximum number of elements is 20. NOTE: Suggest API supports only few filters at the moment: "objecttype", "type" and "mimetype". For now, schema specific filters cannot be used to filter suggestions.
	FilterOptions FilterOptionsArrayInput `pulumi:"filterOptions"`
	// The source of restriction.
	Source SourcePtrInput `pulumi:"source"`
}

func (DataSourceRestrictionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DataSourceRestriction)(nil)).Elem()
}

func (i DataSourceRestrictionArgs) ToDataSourceRestrictionOutput() DataSourceRestrictionOutput {
	return i.ToDataSourceRestrictionOutputWithContext(context.Background())
}

func (i DataSourceRestrictionArgs) ToDataSourceRestrictionOutputWithContext(ctx context.Context) DataSourceRestrictionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataSourceRestrictionOutput)
}

// DataSourceRestrictionArrayInput is an input type that accepts DataSourceRestrictionArray and DataSourceRestrictionArrayOutput values.
// You can construct a concrete instance of `DataSourceRestrictionArrayInput` via:
//
//          DataSourceRestrictionArray{ DataSourceRestrictionArgs{...} }
type DataSourceRestrictionArrayInput interface {
	pulumi.Input

	ToDataSourceRestrictionArrayOutput() DataSourceRestrictionArrayOutput
	ToDataSourceRestrictionArrayOutputWithContext(context.Context) DataSourceRestrictionArrayOutput
}

type DataSourceRestrictionArray []DataSourceRestrictionInput

func (DataSourceRestrictionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DataSourceRestriction)(nil)).Elem()
}

func (i DataSourceRestrictionArray) ToDataSourceRestrictionArrayOutput() DataSourceRestrictionArrayOutput {
	return i.ToDataSourceRestrictionArrayOutputWithContext(context.Background())
}

func (i DataSourceRestrictionArray) ToDataSourceRestrictionArrayOutputWithContext(ctx context.Context) DataSourceRestrictionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataSourceRestrictionArrayOutput)
}

// Restriction on Datasource.
type DataSourceRestrictionOutput struct{ *pulumi.OutputState }

func (DataSourceRestrictionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DataSourceRestriction)(nil)).Elem()
}

func (o DataSourceRestrictionOutput) ToDataSourceRestrictionOutput() DataSourceRestrictionOutput {
	return o
}

func (o DataSourceRestrictionOutput) ToDataSourceRestrictionOutputWithContext(ctx context.Context) DataSourceRestrictionOutput {
	return o
}

// Filter options restricting the results. If multiple filters are present, they are grouped by object type before joining. Filters with the same object type are joined conjunctively, then the resulting expressions are joined disjunctively. The maximum number of elements is 20. NOTE: Suggest API supports only few filters at the moment: "objecttype", "type" and "mimetype". For now, schema specific filters cannot be used to filter suggestions.
func (o DataSourceRestrictionOutput) FilterOptions() FilterOptionsArrayOutput {
	return o.ApplyT(func(v DataSourceRestriction) []FilterOptions { return v.FilterOptions }).(FilterOptionsArrayOutput)
}

// The source of restriction.
func (o DataSourceRestrictionOutput) Source() SourcePtrOutput {
	return o.ApplyT(func(v DataSourceRestriction) *Source { return v.Source }).(SourcePtrOutput)
}

type DataSourceRestrictionArrayOutput struct{ *pulumi.OutputState }

func (DataSourceRestrictionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DataSourceRestriction)(nil)).Elem()
}

func (o DataSourceRestrictionArrayOutput) ToDataSourceRestrictionArrayOutput() DataSourceRestrictionArrayOutput {
	return o
}

func (o DataSourceRestrictionArrayOutput) ToDataSourceRestrictionArrayOutputWithContext(ctx context.Context) DataSourceRestrictionArrayOutput {
	return o
}

func (o DataSourceRestrictionArrayOutput) Index(i pulumi.IntInput) DataSourceRestrictionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DataSourceRestriction {
		return vs[0].([]DataSourceRestriction)[vs[1].(int)]
	}).(DataSourceRestrictionOutput)
}

// Represents a whole calendar date, for example a date of birth. The time of day and time zone are either specified elsewhere or are not significant. The date is relative to the [Proleptic Gregorian Calendar](https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar). The date must be a valid calendar date between the year 1 and 9999.
type Date struct {
	// Day of month. Must be from 1 to 31 and valid for the year and month.
	Day *int `pulumi:"day"`
	// Month of date. Must be from 1 to 12.
	Month *int `pulumi:"month"`
	// Year of date. Must be from 1 to 9999.
	Year *int `pulumi:"year"`
}

// DateInput is an input type that accepts DateArgs and DateOutput values.
// You can construct a concrete instance of `DateInput` via:
//
//          DateArgs{...}
type DateInput interface {
	pulumi.Input

	ToDateOutput() DateOutput
	ToDateOutputWithContext(context.Context) DateOutput
}

// Represents a whole calendar date, for example a date of birth. The time of day and time zone are either specified elsewhere or are not significant. The date is relative to the [Proleptic Gregorian Calendar](https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar). The date must be a valid calendar date between the year 1 and 9999.
type DateArgs struct {
	// Day of month. Must be from 1 to 31 and valid for the year and month.
	Day pulumi.IntPtrInput `pulumi:"day"`
	// Month of date. Must be from 1 to 12.
	Month pulumi.IntPtrInput `pulumi:"month"`
	// Year of date. Must be from 1 to 9999.
	Year pulumi.IntPtrInput `pulumi:"year"`
}

func (DateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Date)(nil)).Elem()
}

func (i DateArgs) ToDateOutput() DateOutput {
	return i.ToDateOutputWithContext(context.Background())
}

func (i DateArgs) ToDateOutputWithContext(ctx context.Context) DateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DateOutput)
}

func (i DateArgs) ToDatePtrOutput() DatePtrOutput {
	return i.ToDatePtrOutputWithContext(context.Background())
}

func (i DateArgs) ToDatePtrOutputWithContext(ctx context.Context) DatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DateOutput).ToDatePtrOutputWithContext(ctx)
}

// DatePtrInput is an input type that accepts DateArgs, DatePtr and DatePtrOutput values.
// You can construct a concrete instance of `DatePtrInput` via:
//
//          DateArgs{...}
//
//  or:
//
//          nil
type DatePtrInput interface {
	pulumi.Input

	ToDatePtrOutput() DatePtrOutput
	ToDatePtrOutputWithContext(context.Context) DatePtrOutput
}

type datePtrType DateArgs

func DatePtr(v *DateArgs) DatePtrInput {
	return (*datePtrType)(v)
}

func (*datePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Date)(nil)).Elem()
}

func (i *datePtrType) ToDatePtrOutput() DatePtrOutput {
	return i.ToDatePtrOutputWithContext(context.Background())
}

func (i *datePtrType) ToDatePtrOutputWithContext(ctx context.Context) DatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatePtrOutput)
}

// Represents a whole calendar date, for example a date of birth. The time of day and time zone are either specified elsewhere or are not significant. The date is relative to the [Proleptic Gregorian Calendar](https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar). The date must be a valid calendar date between the year 1 and 9999.
type DateOutput struct{ *pulumi.OutputState }

func (DateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Date)(nil)).Elem()
}

func (o DateOutput) ToDateOutput() DateOutput {
	return o
}

func (o DateOutput) ToDateOutputWithContext(ctx context.Context) DateOutput {
	return o
}

func (o DateOutput) ToDatePtrOutput() DatePtrOutput {
	return o.ToDatePtrOutputWithContext(context.Background())
}

func (o DateOutput) ToDatePtrOutputWithContext(ctx context.Context) DatePtrOutput {
	return o.ApplyT(func(v Date) *Date {
		return &v
	}).(DatePtrOutput)
}

// Day of month. Must be from 1 to 31 and valid for the year and month.
func (o DateOutput) Day() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Date) *int { return v.Day }).(pulumi.IntPtrOutput)
}

// Month of date. Must be from 1 to 12.
func (o DateOutput) Month() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Date) *int { return v.Month }).(pulumi.IntPtrOutput)
}

// Year of date. Must be from 1 to 9999.
func (o DateOutput) Year() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Date) *int { return v.Year }).(pulumi.IntPtrOutput)
}

type DatePtrOutput struct{ *pulumi.OutputState }

func (DatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Date)(nil)).Elem()
}

func (o DatePtrOutput) ToDatePtrOutput() DatePtrOutput {
	return o
}

func (o DatePtrOutput) ToDatePtrOutputWithContext(ctx context.Context) DatePtrOutput {
	return o
}

func (o DatePtrOutput) Elem() DateOutput {
	return o.ApplyT(func(v *Date) Date { return *v }).(DateOutput)
}

// Day of month. Must be from 1 to 31 and valid for the year and month.
func (o DatePtrOutput) Day() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Date) *int {
		if v == nil {
			return nil
		}
		return v.Day
	}).(pulumi.IntPtrOutput)
}

// Month of date. Must be from 1 to 12.
func (o DatePtrOutput) Month() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Date) *int {
		if v == nil {
			return nil
		}
		return v.Month
	}).(pulumi.IntPtrOutput)
}

// Year of date. Must be from 1 to 9999.
func (o DatePtrOutput) Year() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Date) *int {
		if v == nil {
			return nil
		}
		return v.Year
	}).(pulumi.IntPtrOutput)
}

// Specifies operators to return facet results for. There will be one FacetResult for every source_name/object_type/operator_name combination.
type FacetOptions struct {
	// Maximum number of facet buckets that should be returned for this facet. Defaults to 10. Maximum value is 100.
	NumFacetBuckets *int `pulumi:"numFacetBuckets"`
	// If object_type is set, only those objects of that type will be used to compute facets. If empty, then all objects will be used to compute facets.
	ObjectType *string `pulumi:"objectType"`
	// Name of the operator chosen for faceting. @see cloudsearch.SchemaPropertyOptions
	OperatorName *string `pulumi:"operatorName"`
	// Source name to facet on. Format: datasources/{source_id} If empty, all data sources will be used.
	SourceName *string `pulumi:"sourceName"`
}

// FacetOptionsInput is an input type that accepts FacetOptionsArgs and FacetOptionsOutput values.
// You can construct a concrete instance of `FacetOptionsInput` via:
//
//          FacetOptionsArgs{...}
type FacetOptionsInput interface {
	pulumi.Input

	ToFacetOptionsOutput() FacetOptionsOutput
	ToFacetOptionsOutputWithContext(context.Context) FacetOptionsOutput
}

// Specifies operators to return facet results for. There will be one FacetResult for every source_name/object_type/operator_name combination.
type FacetOptionsArgs struct {
	// Maximum number of facet buckets that should be returned for this facet. Defaults to 10. Maximum value is 100.
	NumFacetBuckets pulumi.IntPtrInput `pulumi:"numFacetBuckets"`
	// If object_type is set, only those objects of that type will be used to compute facets. If empty, then all objects will be used to compute facets.
	ObjectType pulumi.StringPtrInput `pulumi:"objectType"`
	// Name of the operator chosen for faceting. @see cloudsearch.SchemaPropertyOptions
	OperatorName pulumi.StringPtrInput `pulumi:"operatorName"`
	// Source name to facet on. Format: datasources/{source_id} If empty, all data sources will be used.
	SourceName pulumi.StringPtrInput `pulumi:"sourceName"`
}

func (FacetOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FacetOptions)(nil)).Elem()
}

func (i FacetOptionsArgs) ToFacetOptionsOutput() FacetOptionsOutput {
	return i.ToFacetOptionsOutputWithContext(context.Background())
}

func (i FacetOptionsArgs) ToFacetOptionsOutputWithContext(ctx context.Context) FacetOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FacetOptionsOutput)
}

// FacetOptionsArrayInput is an input type that accepts FacetOptionsArray and FacetOptionsArrayOutput values.
// You can construct a concrete instance of `FacetOptionsArrayInput` via:
//
//          FacetOptionsArray{ FacetOptionsArgs{...} }
type FacetOptionsArrayInput interface {
	pulumi.Input

	ToFacetOptionsArrayOutput() FacetOptionsArrayOutput
	ToFacetOptionsArrayOutputWithContext(context.Context) FacetOptionsArrayOutput
}

type FacetOptionsArray []FacetOptionsInput

func (FacetOptionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FacetOptions)(nil)).Elem()
}

func (i FacetOptionsArray) ToFacetOptionsArrayOutput() FacetOptionsArrayOutput {
	return i.ToFacetOptionsArrayOutputWithContext(context.Background())
}

func (i FacetOptionsArray) ToFacetOptionsArrayOutputWithContext(ctx context.Context) FacetOptionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FacetOptionsArrayOutput)
}

// Specifies operators to return facet results for. There will be one FacetResult for every source_name/object_type/operator_name combination.
type FacetOptionsOutput struct{ *pulumi.OutputState }

func (FacetOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FacetOptions)(nil)).Elem()
}

func (o FacetOptionsOutput) ToFacetOptionsOutput() FacetOptionsOutput {
	return o
}

func (o FacetOptionsOutput) ToFacetOptionsOutputWithContext(ctx context.Context) FacetOptionsOutput {
	return o
}

// Maximum number of facet buckets that should be returned for this facet. Defaults to 10. Maximum value is 100.
func (o FacetOptionsOutput) NumFacetBuckets() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FacetOptions) *int { return v.NumFacetBuckets }).(pulumi.IntPtrOutput)
}

// If object_type is set, only those objects of that type will be used to compute facets. If empty, then all objects will be used to compute facets.
func (o FacetOptionsOutput) ObjectType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FacetOptions) *string { return v.ObjectType }).(pulumi.StringPtrOutput)
}

// Name of the operator chosen for faceting. @see cloudsearch.SchemaPropertyOptions
func (o FacetOptionsOutput) OperatorName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FacetOptions) *string { return v.OperatorName }).(pulumi.StringPtrOutput)
}

// Source name to facet on. Format: datasources/{source_id} If empty, all data sources will be used.
func (o FacetOptionsOutput) SourceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FacetOptions) *string { return v.SourceName }).(pulumi.StringPtrOutput)
}

type FacetOptionsArrayOutput struct{ *pulumi.OutputState }

func (FacetOptionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FacetOptions)(nil)).Elem()
}

func (o FacetOptionsArrayOutput) ToFacetOptionsArrayOutput() FacetOptionsArrayOutput {
	return o
}

func (o FacetOptionsArrayOutput) ToFacetOptionsArrayOutputWithContext(ctx context.Context) FacetOptionsArrayOutput {
	return o
}

func (o FacetOptionsArrayOutput) Index(i pulumi.IntInput) FacetOptionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FacetOptions {
		return vs[0].([]FacetOptions)[vs[1].(int)]
	}).(FacetOptionsOutput)
}

// A generic way of expressing filters in a query, which supports two approaches: **1. Setting a ValueFilter.** The name must match an operator_name defined in the schema for your data source. **2. Setting a CompositeFilter.** The filters are evaluated using the logical operator. The top-level operators can only be either an AND or a NOT. AND can appear only at the top-most level. OR can appear only under a top-level AND.
type Filter struct {
	CompositeFilter *CompositeFilter `pulumi:"compositeFilter"`
	ValueFilter     *ValueFilter     `pulumi:"valueFilter"`
}

// FilterInput is an input type that accepts FilterArgs and FilterOutput values.
// You can construct a concrete instance of `FilterInput` via:
//
//          FilterArgs{...}
type FilterInput interface {
	pulumi.Input

	ToFilterOutput() FilterOutput
	ToFilterOutputWithContext(context.Context) FilterOutput
}

// A generic way of expressing filters in a query, which supports two approaches: **1. Setting a ValueFilter.** The name must match an operator_name defined in the schema for your data source. **2. Setting a CompositeFilter.** The filters are evaluated using the logical operator. The top-level operators can only be either an AND or a NOT. AND can appear only at the top-most level. OR can appear only under a top-level AND.
type FilterArgs struct {
	CompositeFilter CompositeFilterPtrInput `pulumi:"compositeFilter"`
	ValueFilter     ValueFilterPtrInput     `pulumi:"valueFilter"`
}

func (FilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Filter)(nil)).Elem()
}

func (i FilterArgs) ToFilterOutput() FilterOutput {
	return i.ToFilterOutputWithContext(context.Background())
}

func (i FilterArgs) ToFilterOutputWithContext(ctx context.Context) FilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FilterOutput)
}

func (i FilterArgs) ToFilterPtrOutput() FilterPtrOutput {
	return i.ToFilterPtrOutputWithContext(context.Background())
}

func (i FilterArgs) ToFilterPtrOutputWithContext(ctx context.Context) FilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FilterOutput).ToFilterPtrOutputWithContext(ctx)
}

// FilterPtrInput is an input type that accepts FilterArgs, FilterPtr and FilterPtrOutput values.
// You can construct a concrete instance of `FilterPtrInput` via:
//
//          FilterArgs{...}
//
//  or:
//
//          nil
type FilterPtrInput interface {
	pulumi.Input

	ToFilterPtrOutput() FilterPtrOutput
	ToFilterPtrOutputWithContext(context.Context) FilterPtrOutput
}

type filterPtrType FilterArgs

func FilterPtr(v *FilterArgs) FilterPtrInput {
	return (*filterPtrType)(v)
}

func (*filterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Filter)(nil)).Elem()
}

func (i *filterPtrType) ToFilterPtrOutput() FilterPtrOutput {
	return i.ToFilterPtrOutputWithContext(context.Background())
}

func (i *filterPtrType) ToFilterPtrOutputWithContext(ctx context.Context) FilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FilterPtrOutput)
}

// FilterArrayInput is an input type that accepts FilterArray and FilterArrayOutput values.
// You can construct a concrete instance of `FilterArrayInput` via:
//
//          FilterArray{ FilterArgs{...} }
type FilterArrayInput interface {
	pulumi.Input

	ToFilterArrayOutput() FilterArrayOutput
	ToFilterArrayOutputWithContext(context.Context) FilterArrayOutput
}

type FilterArray []FilterInput

func (FilterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Filter)(nil)).Elem()
}

func (i FilterArray) ToFilterArrayOutput() FilterArrayOutput {
	return i.ToFilterArrayOutputWithContext(context.Background())
}

func (i FilterArray) ToFilterArrayOutputWithContext(ctx context.Context) FilterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FilterArrayOutput)
}

// A generic way of expressing filters in a query, which supports two approaches: **1. Setting a ValueFilter.** The name must match an operator_name defined in the schema for your data source. **2. Setting a CompositeFilter.** The filters are evaluated using the logical operator. The top-level operators can only be either an AND or a NOT. AND can appear only at the top-most level. OR can appear only under a top-level AND.
type FilterOutput struct{ *pulumi.OutputState }

func (FilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Filter)(nil)).Elem()
}

func (o FilterOutput) ToFilterOutput() FilterOutput {
	return o
}

func (o FilterOutput) ToFilterOutputWithContext(ctx context.Context) FilterOutput {
	return o
}

func (o FilterOutput) ToFilterPtrOutput() FilterPtrOutput {
	return o.ToFilterPtrOutputWithContext(context.Background())
}

func (o FilterOutput) ToFilterPtrOutputWithContext(ctx context.Context) FilterPtrOutput {
	return o.ApplyT(func(v Filter) *Filter {
		return &v
	}).(FilterPtrOutput)
}
func (o FilterOutput) CompositeFilter() CompositeFilterPtrOutput {
	return o.ApplyT(func(v Filter) *CompositeFilter { return v.CompositeFilter }).(CompositeFilterPtrOutput)
}

func (o FilterOutput) ValueFilter() ValueFilterPtrOutput {
	return o.ApplyT(func(v Filter) *ValueFilter { return v.ValueFilter }).(ValueFilterPtrOutput)
}

type FilterPtrOutput struct{ *pulumi.OutputState }

func (FilterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Filter)(nil)).Elem()
}

func (o FilterPtrOutput) ToFilterPtrOutput() FilterPtrOutput {
	return o
}

func (o FilterPtrOutput) ToFilterPtrOutputWithContext(ctx context.Context) FilterPtrOutput {
	return o
}

func (o FilterPtrOutput) Elem() FilterOutput {
	return o.ApplyT(func(v *Filter) Filter { return *v }).(FilterOutput)
}

func (o FilterPtrOutput) CompositeFilter() CompositeFilterPtrOutput {
	return o.ApplyT(func(v *Filter) *CompositeFilter {
		if v == nil {
			return nil
		}
		return v.CompositeFilter
	}).(CompositeFilterPtrOutput)
}

func (o FilterPtrOutput) ValueFilter() ValueFilterPtrOutput {
	return o.ApplyT(func(v *Filter) *ValueFilter {
		if v == nil {
			return nil
		}
		return v.ValueFilter
	}).(ValueFilterPtrOutput)
}

type FilterArrayOutput struct{ *pulumi.OutputState }

func (FilterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Filter)(nil)).Elem()
}

func (o FilterArrayOutput) ToFilterArrayOutput() FilterArrayOutput {
	return o
}

func (o FilterArrayOutput) ToFilterArrayOutputWithContext(ctx context.Context) FilterArrayOutput {
	return o
}

func (o FilterArrayOutput) Index(i pulumi.IntInput) FilterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Filter {
		return vs[0].([]Filter)[vs[1].(int)]
	}).(FilterOutput)
}

// Filter options to be applied on query.
type FilterOptions struct {
	// Generic filter to restrict the search, such as `lang:en`, `site:xyz`.
	Filter *Filter `pulumi:"filter"`
	// If object_type is set, only objects of that type are returned. This should correspond to the name of the object that was registered within the definition of schema. The maximum length is 256 characters.
	ObjectType *string `pulumi:"objectType"`
}

// FilterOptionsInput is an input type that accepts FilterOptionsArgs and FilterOptionsOutput values.
// You can construct a concrete instance of `FilterOptionsInput` via:
//
//          FilterOptionsArgs{...}
type FilterOptionsInput interface {
	pulumi.Input

	ToFilterOptionsOutput() FilterOptionsOutput
	ToFilterOptionsOutputWithContext(context.Context) FilterOptionsOutput
}

// Filter options to be applied on query.
type FilterOptionsArgs struct {
	// Generic filter to restrict the search, such as `lang:en`, `site:xyz`.
	Filter FilterPtrInput `pulumi:"filter"`
	// If object_type is set, only objects of that type are returned. This should correspond to the name of the object that was registered within the definition of schema. The maximum length is 256 characters.
	ObjectType pulumi.StringPtrInput `pulumi:"objectType"`
}

func (FilterOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FilterOptions)(nil)).Elem()
}

func (i FilterOptionsArgs) ToFilterOptionsOutput() FilterOptionsOutput {
	return i.ToFilterOptionsOutputWithContext(context.Background())
}

func (i FilterOptionsArgs) ToFilterOptionsOutputWithContext(ctx context.Context) FilterOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FilterOptionsOutput)
}

// FilterOptionsArrayInput is an input type that accepts FilterOptionsArray and FilterOptionsArrayOutput values.
// You can construct a concrete instance of `FilterOptionsArrayInput` via:
//
//          FilterOptionsArray{ FilterOptionsArgs{...} }
type FilterOptionsArrayInput interface {
	pulumi.Input

	ToFilterOptionsArrayOutput() FilterOptionsArrayOutput
	ToFilterOptionsArrayOutputWithContext(context.Context) FilterOptionsArrayOutput
}

type FilterOptionsArray []FilterOptionsInput

func (FilterOptionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FilterOptions)(nil)).Elem()
}

func (i FilterOptionsArray) ToFilterOptionsArrayOutput() FilterOptionsArrayOutput {
	return i.ToFilterOptionsArrayOutputWithContext(context.Background())
}

func (i FilterOptionsArray) ToFilterOptionsArrayOutputWithContext(ctx context.Context) FilterOptionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FilterOptionsArrayOutput)
}

// Filter options to be applied on query.
type FilterOptionsOutput struct{ *pulumi.OutputState }

func (FilterOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FilterOptions)(nil)).Elem()
}

func (o FilterOptionsOutput) ToFilterOptionsOutput() FilterOptionsOutput {
	return o
}

func (o FilterOptionsOutput) ToFilterOptionsOutputWithContext(ctx context.Context) FilterOptionsOutput {
	return o
}

// Generic filter to restrict the search, such as `lang:en`, `site:xyz`.
func (o FilterOptionsOutput) Filter() FilterPtrOutput {
	return o.ApplyT(func(v FilterOptions) *Filter { return v.Filter }).(FilterPtrOutput)
}

// If object_type is set, only objects of that type are returned. This should correspond to the name of the object that was registered within the definition of schema. The maximum length is 256 characters.
func (o FilterOptionsOutput) ObjectType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FilterOptions) *string { return v.ObjectType }).(pulumi.StringPtrOutput)
}

type FilterOptionsArrayOutput struct{ *pulumi.OutputState }

func (FilterOptionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FilterOptions)(nil)).Elem()
}

func (o FilterOptionsArrayOutput) ToFilterOptionsArrayOutput() FilterOptionsArrayOutput {
	return o
}

func (o FilterOptionsArrayOutput) ToFilterOptionsArrayOutputWithContext(ctx context.Context) FilterOptionsArrayOutput {
	return o
}

func (o FilterOptionsArrayOutput) Index(i pulumi.IntInput) FilterOptionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FilterOptions {
		return vs[0].([]FilterOptions)[vs[1].(int)]
	}).(FilterOptionsOutput)
}

type GSuitePrincipal struct {
	// This principal represents all users of the G Suite domain of the customer.
	GsuiteDomain *bool `pulumi:"gsuiteDomain"`
	// This principal references a G Suite group account
	GsuiteGroupEmail *string `pulumi:"gsuiteGroupEmail"`
	// This principal references a G Suite user account
	GsuiteUserEmail *string `pulumi:"gsuiteUserEmail"`
}

// GSuitePrincipalInput is an input type that accepts GSuitePrincipalArgs and GSuitePrincipalOutput values.
// You can construct a concrete instance of `GSuitePrincipalInput` via:
//
//          GSuitePrincipalArgs{...}
type GSuitePrincipalInput interface {
	pulumi.Input

	ToGSuitePrincipalOutput() GSuitePrincipalOutput
	ToGSuitePrincipalOutputWithContext(context.Context) GSuitePrincipalOutput
}

type GSuitePrincipalArgs struct {
	// This principal represents all users of the G Suite domain of the customer.
	GsuiteDomain pulumi.BoolPtrInput `pulumi:"gsuiteDomain"`
	// This principal references a G Suite group account
	GsuiteGroupEmail pulumi.StringPtrInput `pulumi:"gsuiteGroupEmail"`
	// This principal references a G Suite user account
	GsuiteUserEmail pulumi.StringPtrInput `pulumi:"gsuiteUserEmail"`
}

func (GSuitePrincipalArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GSuitePrincipal)(nil)).Elem()
}

func (i GSuitePrincipalArgs) ToGSuitePrincipalOutput() GSuitePrincipalOutput {
	return i.ToGSuitePrincipalOutputWithContext(context.Background())
}

func (i GSuitePrincipalArgs) ToGSuitePrincipalOutputWithContext(ctx context.Context) GSuitePrincipalOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GSuitePrincipalOutput)
}

// GSuitePrincipalArrayInput is an input type that accepts GSuitePrincipalArray and GSuitePrincipalArrayOutput values.
// You can construct a concrete instance of `GSuitePrincipalArrayInput` via:
//
//          GSuitePrincipalArray{ GSuitePrincipalArgs{...} }
type GSuitePrincipalArrayInput interface {
	pulumi.Input

	ToGSuitePrincipalArrayOutput() GSuitePrincipalArrayOutput
	ToGSuitePrincipalArrayOutputWithContext(context.Context) GSuitePrincipalArrayOutput
}

type GSuitePrincipalArray []GSuitePrincipalInput

func (GSuitePrincipalArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GSuitePrincipal)(nil)).Elem()
}

func (i GSuitePrincipalArray) ToGSuitePrincipalArrayOutput() GSuitePrincipalArrayOutput {
	return i.ToGSuitePrincipalArrayOutputWithContext(context.Background())
}

func (i GSuitePrincipalArray) ToGSuitePrincipalArrayOutputWithContext(ctx context.Context) GSuitePrincipalArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GSuitePrincipalArrayOutput)
}

type GSuitePrincipalOutput struct{ *pulumi.OutputState }

func (GSuitePrincipalOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GSuitePrincipal)(nil)).Elem()
}

func (o GSuitePrincipalOutput) ToGSuitePrincipalOutput() GSuitePrincipalOutput {
	return o
}

func (o GSuitePrincipalOutput) ToGSuitePrincipalOutputWithContext(ctx context.Context) GSuitePrincipalOutput {
	return o
}

// This principal represents all users of the G Suite domain of the customer.
func (o GSuitePrincipalOutput) GsuiteDomain() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GSuitePrincipal) *bool { return v.GsuiteDomain }).(pulumi.BoolPtrOutput)
}

// This principal references a G Suite group account
func (o GSuitePrincipalOutput) GsuiteGroupEmail() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GSuitePrincipal) *string { return v.GsuiteGroupEmail }).(pulumi.StringPtrOutput)
}

// This principal references a G Suite user account
func (o GSuitePrincipalOutput) GsuiteUserEmail() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GSuitePrincipal) *string { return v.GsuiteUserEmail }).(pulumi.StringPtrOutput)
}

type GSuitePrincipalArrayOutput struct{ *pulumi.OutputState }

func (GSuitePrincipalArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GSuitePrincipal)(nil)).Elem()
}

func (o GSuitePrincipalArrayOutput) ToGSuitePrincipalArrayOutput() GSuitePrincipalArrayOutput {
	return o
}

func (o GSuitePrincipalArrayOutput) ToGSuitePrincipalArrayOutputWithContext(ctx context.Context) GSuitePrincipalArrayOutput {
	return o
}

func (o GSuitePrincipalArrayOutput) Index(i pulumi.IntInput) GSuitePrincipalOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GSuitePrincipal {
		return vs[0].([]GSuitePrincipal)[vs[1].(int)]
	}).(GSuitePrincipalOutput)
}

// Scoring configurations for a source while processing a Search or Suggest request.
type ScoringConfig struct {
	// Whether to use freshness as a ranking signal. By default, freshness is used as a ranking signal. Note that this setting is not available in the Admin UI.
	DisableFreshness *bool `pulumi:"disableFreshness"`
	// Whether to personalize the results. By default, personal signals will be used to boost results.
	DisablePersonalization *bool `pulumi:"disablePersonalization"`
}

// ScoringConfigInput is an input type that accepts ScoringConfigArgs and ScoringConfigOutput values.
// You can construct a concrete instance of `ScoringConfigInput` via:
//
//          ScoringConfigArgs{...}
type ScoringConfigInput interface {
	pulumi.Input

	ToScoringConfigOutput() ScoringConfigOutput
	ToScoringConfigOutputWithContext(context.Context) ScoringConfigOutput
}

// Scoring configurations for a source while processing a Search or Suggest request.
type ScoringConfigArgs struct {
	// Whether to use freshness as a ranking signal. By default, freshness is used as a ranking signal. Note that this setting is not available in the Admin UI.
	DisableFreshness pulumi.BoolPtrInput `pulumi:"disableFreshness"`
	// Whether to personalize the results. By default, personal signals will be used to boost results.
	DisablePersonalization pulumi.BoolPtrInput `pulumi:"disablePersonalization"`
}

func (ScoringConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScoringConfig)(nil)).Elem()
}

func (i ScoringConfigArgs) ToScoringConfigOutput() ScoringConfigOutput {
	return i.ToScoringConfigOutputWithContext(context.Background())
}

func (i ScoringConfigArgs) ToScoringConfigOutputWithContext(ctx context.Context) ScoringConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScoringConfigOutput)
}

func (i ScoringConfigArgs) ToScoringConfigPtrOutput() ScoringConfigPtrOutput {
	return i.ToScoringConfigPtrOutputWithContext(context.Background())
}

func (i ScoringConfigArgs) ToScoringConfigPtrOutputWithContext(ctx context.Context) ScoringConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScoringConfigOutput).ToScoringConfigPtrOutputWithContext(ctx)
}

// ScoringConfigPtrInput is an input type that accepts ScoringConfigArgs, ScoringConfigPtr and ScoringConfigPtrOutput values.
// You can construct a concrete instance of `ScoringConfigPtrInput` via:
//
//          ScoringConfigArgs{...}
//
//  or:
//
//          nil
type ScoringConfigPtrInput interface {
	pulumi.Input

	ToScoringConfigPtrOutput() ScoringConfigPtrOutput
	ToScoringConfigPtrOutputWithContext(context.Context) ScoringConfigPtrOutput
}

type scoringConfigPtrType ScoringConfigArgs

func ScoringConfigPtr(v *ScoringConfigArgs) ScoringConfigPtrInput {
	return (*scoringConfigPtrType)(v)
}

func (*scoringConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ScoringConfig)(nil)).Elem()
}

func (i *scoringConfigPtrType) ToScoringConfigPtrOutput() ScoringConfigPtrOutput {
	return i.ToScoringConfigPtrOutputWithContext(context.Background())
}

func (i *scoringConfigPtrType) ToScoringConfigPtrOutputWithContext(ctx context.Context) ScoringConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScoringConfigPtrOutput)
}

// Scoring configurations for a source while processing a Search or Suggest request.
type ScoringConfigOutput struct{ *pulumi.OutputState }

func (ScoringConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScoringConfig)(nil)).Elem()
}

func (o ScoringConfigOutput) ToScoringConfigOutput() ScoringConfigOutput {
	return o
}

func (o ScoringConfigOutput) ToScoringConfigOutputWithContext(ctx context.Context) ScoringConfigOutput {
	return o
}

func (o ScoringConfigOutput) ToScoringConfigPtrOutput() ScoringConfigPtrOutput {
	return o.ToScoringConfigPtrOutputWithContext(context.Background())
}

func (o ScoringConfigOutput) ToScoringConfigPtrOutputWithContext(ctx context.Context) ScoringConfigPtrOutput {
	return o.ApplyT(func(v ScoringConfig) *ScoringConfig {
		return &v
	}).(ScoringConfigPtrOutput)
}

// Whether to use freshness as a ranking signal. By default, freshness is used as a ranking signal. Note that this setting is not available in the Admin UI.
func (o ScoringConfigOutput) DisableFreshness() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ScoringConfig) *bool { return v.DisableFreshness }).(pulumi.BoolPtrOutput)
}

// Whether to personalize the results. By default, personal signals will be used to boost results.
func (o ScoringConfigOutput) DisablePersonalization() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ScoringConfig) *bool { return v.DisablePersonalization }).(pulumi.BoolPtrOutput)
}

type ScoringConfigPtrOutput struct{ *pulumi.OutputState }

func (ScoringConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ScoringConfig)(nil)).Elem()
}

func (o ScoringConfigPtrOutput) ToScoringConfigPtrOutput() ScoringConfigPtrOutput {
	return o
}

func (o ScoringConfigPtrOutput) ToScoringConfigPtrOutputWithContext(ctx context.Context) ScoringConfigPtrOutput {
	return o
}

func (o ScoringConfigPtrOutput) Elem() ScoringConfigOutput {
	return o.ApplyT(func(v *ScoringConfig) ScoringConfig { return *v }).(ScoringConfigOutput)
}

// Whether to use freshness as a ranking signal. By default, freshness is used as a ranking signal. Note that this setting is not available in the Admin UI.
func (o ScoringConfigPtrOutput) DisableFreshness() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ScoringConfig) *bool {
		if v == nil {
			return nil
		}
		return v.DisableFreshness
	}).(pulumi.BoolPtrOutput)
}

// Whether to personalize the results. By default, personal signals will be used to boost results.
func (o ScoringConfigPtrOutput) DisablePersonalization() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ScoringConfig) *bool {
		if v == nil {
			return nil
		}
		return v.DisablePersonalization
	}).(pulumi.BoolPtrOutput)
}

type SortOptions struct {
	// Name of the operator corresponding to the field to sort on. The corresponding property must be marked as sortable.
	OperatorName *string `pulumi:"operatorName"`
	// Ascending is the default sort order
	SortOrder *string `pulumi:"sortOrder"`
}

// SortOptionsInput is an input type that accepts SortOptionsArgs and SortOptionsOutput values.
// You can construct a concrete instance of `SortOptionsInput` via:
//
//          SortOptionsArgs{...}
type SortOptionsInput interface {
	pulumi.Input

	ToSortOptionsOutput() SortOptionsOutput
	ToSortOptionsOutputWithContext(context.Context) SortOptionsOutput
}

type SortOptionsArgs struct {
	// Name of the operator corresponding to the field to sort on. The corresponding property must be marked as sortable.
	OperatorName pulumi.StringPtrInput `pulumi:"operatorName"`
	// Ascending is the default sort order
	SortOrder pulumi.StringPtrInput `pulumi:"sortOrder"`
}

func (SortOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SortOptions)(nil)).Elem()
}

func (i SortOptionsArgs) ToSortOptionsOutput() SortOptionsOutput {
	return i.ToSortOptionsOutputWithContext(context.Background())
}

func (i SortOptionsArgs) ToSortOptionsOutputWithContext(ctx context.Context) SortOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SortOptionsOutput)
}

func (i SortOptionsArgs) ToSortOptionsPtrOutput() SortOptionsPtrOutput {
	return i.ToSortOptionsPtrOutputWithContext(context.Background())
}

func (i SortOptionsArgs) ToSortOptionsPtrOutputWithContext(ctx context.Context) SortOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SortOptionsOutput).ToSortOptionsPtrOutputWithContext(ctx)
}

// SortOptionsPtrInput is an input type that accepts SortOptionsArgs, SortOptionsPtr and SortOptionsPtrOutput values.
// You can construct a concrete instance of `SortOptionsPtrInput` via:
//
//          SortOptionsArgs{...}
//
//  or:
//
//          nil
type SortOptionsPtrInput interface {
	pulumi.Input

	ToSortOptionsPtrOutput() SortOptionsPtrOutput
	ToSortOptionsPtrOutputWithContext(context.Context) SortOptionsPtrOutput
}

type sortOptionsPtrType SortOptionsArgs

func SortOptionsPtr(v *SortOptionsArgs) SortOptionsPtrInput {
	return (*sortOptionsPtrType)(v)
}

func (*sortOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SortOptions)(nil)).Elem()
}

func (i *sortOptionsPtrType) ToSortOptionsPtrOutput() SortOptionsPtrOutput {
	return i.ToSortOptionsPtrOutputWithContext(context.Background())
}

func (i *sortOptionsPtrType) ToSortOptionsPtrOutputWithContext(ctx context.Context) SortOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SortOptionsPtrOutput)
}

type SortOptionsOutput struct{ *pulumi.OutputState }

func (SortOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SortOptions)(nil)).Elem()
}

func (o SortOptionsOutput) ToSortOptionsOutput() SortOptionsOutput {
	return o
}

func (o SortOptionsOutput) ToSortOptionsOutputWithContext(ctx context.Context) SortOptionsOutput {
	return o
}

func (o SortOptionsOutput) ToSortOptionsPtrOutput() SortOptionsPtrOutput {
	return o.ToSortOptionsPtrOutputWithContext(context.Background())
}

func (o SortOptionsOutput) ToSortOptionsPtrOutputWithContext(ctx context.Context) SortOptionsPtrOutput {
	return o.ApplyT(func(v SortOptions) *SortOptions {
		return &v
	}).(SortOptionsPtrOutput)
}

// Name of the operator corresponding to the field to sort on. The corresponding property must be marked as sortable.
func (o SortOptionsOutput) OperatorName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SortOptions) *string { return v.OperatorName }).(pulumi.StringPtrOutput)
}

// Ascending is the default sort order
func (o SortOptionsOutput) SortOrder() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SortOptions) *string { return v.SortOrder }).(pulumi.StringPtrOutput)
}

type SortOptionsPtrOutput struct{ *pulumi.OutputState }

func (SortOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SortOptions)(nil)).Elem()
}

func (o SortOptionsPtrOutput) ToSortOptionsPtrOutput() SortOptionsPtrOutput {
	return o
}

func (o SortOptionsPtrOutput) ToSortOptionsPtrOutputWithContext(ctx context.Context) SortOptionsPtrOutput {
	return o
}

func (o SortOptionsPtrOutput) Elem() SortOptionsOutput {
	return o.ApplyT(func(v *SortOptions) SortOptions { return *v }).(SortOptionsOutput)
}

// Name of the operator corresponding to the field to sort on. The corresponding property must be marked as sortable.
func (o SortOptionsPtrOutput) OperatorName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SortOptions) *string {
		if v == nil {
			return nil
		}
		return v.OperatorName
	}).(pulumi.StringPtrOutput)
}

// Ascending is the default sort order
func (o SortOptionsPtrOutput) SortOrder() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SortOptions) *string {
		if v == nil {
			return nil
		}
		return v.SortOrder
	}).(pulumi.StringPtrOutput)
}

// Defines sources for the suggest/search APIs.
type Source struct {
	// Source name for content indexed by the Indexing API.
	Name *string `pulumi:"name"`
	// Predefined content source for Google Apps.
	PredefinedSource *string `pulumi:"predefinedSource"`
}

// SourceInput is an input type that accepts SourceArgs and SourceOutput values.
// You can construct a concrete instance of `SourceInput` via:
//
//          SourceArgs{...}
type SourceInput interface {
	pulumi.Input

	ToSourceOutput() SourceOutput
	ToSourceOutputWithContext(context.Context) SourceOutput
}

// Defines sources for the suggest/search APIs.
type SourceArgs struct {
	// Source name for content indexed by the Indexing API.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Predefined content source for Google Apps.
	PredefinedSource pulumi.StringPtrInput `pulumi:"predefinedSource"`
}

func (SourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Source)(nil)).Elem()
}

func (i SourceArgs) ToSourceOutput() SourceOutput {
	return i.ToSourceOutputWithContext(context.Background())
}

func (i SourceArgs) ToSourceOutputWithContext(ctx context.Context) SourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceOutput)
}

func (i SourceArgs) ToSourcePtrOutput() SourcePtrOutput {
	return i.ToSourcePtrOutputWithContext(context.Background())
}

func (i SourceArgs) ToSourcePtrOutputWithContext(ctx context.Context) SourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceOutput).ToSourcePtrOutputWithContext(ctx)
}

// SourcePtrInput is an input type that accepts SourceArgs, SourcePtr and SourcePtrOutput values.
// You can construct a concrete instance of `SourcePtrInput` via:
//
//          SourceArgs{...}
//
//  or:
//
//          nil
type SourcePtrInput interface {
	pulumi.Input

	ToSourcePtrOutput() SourcePtrOutput
	ToSourcePtrOutputWithContext(context.Context) SourcePtrOutput
}

type sourcePtrType SourceArgs

func SourcePtr(v *SourceArgs) SourcePtrInput {
	return (*sourcePtrType)(v)
}

func (*sourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Source)(nil)).Elem()
}

func (i *sourcePtrType) ToSourcePtrOutput() SourcePtrOutput {
	return i.ToSourcePtrOutputWithContext(context.Background())
}

func (i *sourcePtrType) ToSourcePtrOutputWithContext(ctx context.Context) SourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourcePtrOutput)
}

// Defines sources for the suggest/search APIs.
type SourceOutput struct{ *pulumi.OutputState }

func (SourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Source)(nil)).Elem()
}

func (o SourceOutput) ToSourceOutput() SourceOutput {
	return o
}

func (o SourceOutput) ToSourceOutputWithContext(ctx context.Context) SourceOutput {
	return o
}

func (o SourceOutput) ToSourcePtrOutput() SourcePtrOutput {
	return o.ToSourcePtrOutputWithContext(context.Background())
}

func (o SourceOutput) ToSourcePtrOutputWithContext(ctx context.Context) SourcePtrOutput {
	return o.ApplyT(func(v Source) *Source {
		return &v
	}).(SourcePtrOutput)
}

// Source name for content indexed by the Indexing API.
func (o SourceOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Source) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Predefined content source for Google Apps.
func (o SourceOutput) PredefinedSource() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Source) *string { return v.PredefinedSource }).(pulumi.StringPtrOutput)
}

type SourcePtrOutput struct{ *pulumi.OutputState }

func (SourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Source)(nil)).Elem()
}

func (o SourcePtrOutput) ToSourcePtrOutput() SourcePtrOutput {
	return o
}

func (o SourcePtrOutput) ToSourcePtrOutputWithContext(ctx context.Context) SourcePtrOutput {
	return o
}

func (o SourcePtrOutput) Elem() SourceOutput {
	return o.ApplyT(func(v *Source) Source { return *v }).(SourceOutput)
}

// Source name for content indexed by the Indexing API.
func (o SourcePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Source) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Predefined content source for Google Apps.
func (o SourcePtrOutput) PredefinedSource() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Source) *string {
		if v == nil {
			return nil
		}
		return v.PredefinedSource
	}).(pulumi.StringPtrOutput)
}

// Configurations for a source while processing a Search or Suggest request.
type SourceConfig struct {
	// The crowding configuration for the source.
	CrowdingConfig *SourceCrowdingConfig `pulumi:"crowdingConfig"`
	// The scoring configuration for the source.
	ScoringConfig *SourceScoringConfig `pulumi:"scoringConfig"`
	// The source for which this configuration is to be used.
	Source *Source `pulumi:"source"`
}

// SourceConfigInput is an input type that accepts SourceConfigArgs and SourceConfigOutput values.
// You can construct a concrete instance of `SourceConfigInput` via:
//
//          SourceConfigArgs{...}
type SourceConfigInput interface {
	pulumi.Input

	ToSourceConfigOutput() SourceConfigOutput
	ToSourceConfigOutputWithContext(context.Context) SourceConfigOutput
}

// Configurations for a source while processing a Search or Suggest request.
type SourceConfigArgs struct {
	// The crowding configuration for the source.
	CrowdingConfig SourceCrowdingConfigPtrInput `pulumi:"crowdingConfig"`
	// The scoring configuration for the source.
	ScoringConfig SourceScoringConfigPtrInput `pulumi:"scoringConfig"`
	// The source for which this configuration is to be used.
	Source SourcePtrInput `pulumi:"source"`
}

func (SourceConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SourceConfig)(nil)).Elem()
}

func (i SourceConfigArgs) ToSourceConfigOutput() SourceConfigOutput {
	return i.ToSourceConfigOutputWithContext(context.Background())
}

func (i SourceConfigArgs) ToSourceConfigOutputWithContext(ctx context.Context) SourceConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceConfigOutput)
}

// SourceConfigArrayInput is an input type that accepts SourceConfigArray and SourceConfigArrayOutput values.
// You can construct a concrete instance of `SourceConfigArrayInput` via:
//
//          SourceConfigArray{ SourceConfigArgs{...} }
type SourceConfigArrayInput interface {
	pulumi.Input

	ToSourceConfigArrayOutput() SourceConfigArrayOutput
	ToSourceConfigArrayOutputWithContext(context.Context) SourceConfigArrayOutput
}

type SourceConfigArray []SourceConfigInput

func (SourceConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SourceConfig)(nil)).Elem()
}

func (i SourceConfigArray) ToSourceConfigArrayOutput() SourceConfigArrayOutput {
	return i.ToSourceConfigArrayOutputWithContext(context.Background())
}

func (i SourceConfigArray) ToSourceConfigArrayOutputWithContext(ctx context.Context) SourceConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceConfigArrayOutput)
}

// Configurations for a source while processing a Search or Suggest request.
type SourceConfigOutput struct{ *pulumi.OutputState }

func (SourceConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SourceConfig)(nil)).Elem()
}

func (o SourceConfigOutput) ToSourceConfigOutput() SourceConfigOutput {
	return o
}

func (o SourceConfigOutput) ToSourceConfigOutputWithContext(ctx context.Context) SourceConfigOutput {
	return o
}

// The crowding configuration for the source.
func (o SourceConfigOutput) CrowdingConfig() SourceCrowdingConfigPtrOutput {
	return o.ApplyT(func(v SourceConfig) *SourceCrowdingConfig { return v.CrowdingConfig }).(SourceCrowdingConfigPtrOutput)
}

// The scoring configuration for the source.
func (o SourceConfigOutput) ScoringConfig() SourceScoringConfigPtrOutput {
	return o.ApplyT(func(v SourceConfig) *SourceScoringConfig { return v.ScoringConfig }).(SourceScoringConfigPtrOutput)
}

// The source for which this configuration is to be used.
func (o SourceConfigOutput) Source() SourcePtrOutput {
	return o.ApplyT(func(v SourceConfig) *Source { return v.Source }).(SourcePtrOutput)
}

type SourceConfigArrayOutput struct{ *pulumi.OutputState }

func (SourceConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SourceConfig)(nil)).Elem()
}

func (o SourceConfigArrayOutput) ToSourceConfigArrayOutput() SourceConfigArrayOutput {
	return o
}

func (o SourceConfigArrayOutput) ToSourceConfigArrayOutputWithContext(ctx context.Context) SourceConfigArrayOutput {
	return o
}

func (o SourceConfigArrayOutput) Index(i pulumi.IntInput) SourceConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SourceConfig {
		return vs[0].([]SourceConfig)[vs[1].(int)]
	}).(SourceConfigOutput)
}

// Set search results crowding limits. Crowding is a situation in which multiple results from the same source or host "crowd out" other results, diminishing the quality of search for users. To foster better search quality and source diversity in search results, you can set a condition to reduce repetitive results by source.
type SourceCrowdingConfig struct {
	// Maximum number of results allowed from a source. No limits will be set on results if this value is less than or equal to 0.
	NumResults *int `pulumi:"numResults"`
	// Maximum number of suggestions allowed from a source. No limits will be set on results if this value is less than or equal to 0.
	NumSuggestions *int `pulumi:"numSuggestions"`
}

// SourceCrowdingConfigInput is an input type that accepts SourceCrowdingConfigArgs and SourceCrowdingConfigOutput values.
// You can construct a concrete instance of `SourceCrowdingConfigInput` via:
//
//          SourceCrowdingConfigArgs{...}
type SourceCrowdingConfigInput interface {
	pulumi.Input

	ToSourceCrowdingConfigOutput() SourceCrowdingConfigOutput
	ToSourceCrowdingConfigOutputWithContext(context.Context) SourceCrowdingConfigOutput
}

// Set search results crowding limits. Crowding is a situation in which multiple results from the same source or host "crowd out" other results, diminishing the quality of search for users. To foster better search quality and source diversity in search results, you can set a condition to reduce repetitive results by source.
type SourceCrowdingConfigArgs struct {
	// Maximum number of results allowed from a source. No limits will be set on results if this value is less than or equal to 0.
	NumResults pulumi.IntPtrInput `pulumi:"numResults"`
	// Maximum number of suggestions allowed from a source. No limits will be set on results if this value is less than or equal to 0.
	NumSuggestions pulumi.IntPtrInput `pulumi:"numSuggestions"`
}

func (SourceCrowdingConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SourceCrowdingConfig)(nil)).Elem()
}

func (i SourceCrowdingConfigArgs) ToSourceCrowdingConfigOutput() SourceCrowdingConfigOutput {
	return i.ToSourceCrowdingConfigOutputWithContext(context.Background())
}

func (i SourceCrowdingConfigArgs) ToSourceCrowdingConfigOutputWithContext(ctx context.Context) SourceCrowdingConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceCrowdingConfigOutput)
}

func (i SourceCrowdingConfigArgs) ToSourceCrowdingConfigPtrOutput() SourceCrowdingConfigPtrOutput {
	return i.ToSourceCrowdingConfigPtrOutputWithContext(context.Background())
}

func (i SourceCrowdingConfigArgs) ToSourceCrowdingConfigPtrOutputWithContext(ctx context.Context) SourceCrowdingConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceCrowdingConfigOutput).ToSourceCrowdingConfigPtrOutputWithContext(ctx)
}

// SourceCrowdingConfigPtrInput is an input type that accepts SourceCrowdingConfigArgs, SourceCrowdingConfigPtr and SourceCrowdingConfigPtrOutput values.
// You can construct a concrete instance of `SourceCrowdingConfigPtrInput` via:
//
//          SourceCrowdingConfigArgs{...}
//
//  or:
//
//          nil
type SourceCrowdingConfigPtrInput interface {
	pulumi.Input

	ToSourceCrowdingConfigPtrOutput() SourceCrowdingConfigPtrOutput
	ToSourceCrowdingConfigPtrOutputWithContext(context.Context) SourceCrowdingConfigPtrOutput
}

type sourceCrowdingConfigPtrType SourceCrowdingConfigArgs

func SourceCrowdingConfigPtr(v *SourceCrowdingConfigArgs) SourceCrowdingConfigPtrInput {
	return (*sourceCrowdingConfigPtrType)(v)
}

func (*sourceCrowdingConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SourceCrowdingConfig)(nil)).Elem()
}

func (i *sourceCrowdingConfigPtrType) ToSourceCrowdingConfigPtrOutput() SourceCrowdingConfigPtrOutput {
	return i.ToSourceCrowdingConfigPtrOutputWithContext(context.Background())
}

func (i *sourceCrowdingConfigPtrType) ToSourceCrowdingConfigPtrOutputWithContext(ctx context.Context) SourceCrowdingConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceCrowdingConfigPtrOutput)
}

// Set search results crowding limits. Crowding is a situation in which multiple results from the same source or host "crowd out" other results, diminishing the quality of search for users. To foster better search quality and source diversity in search results, you can set a condition to reduce repetitive results by source.
type SourceCrowdingConfigOutput struct{ *pulumi.OutputState }

func (SourceCrowdingConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SourceCrowdingConfig)(nil)).Elem()
}

func (o SourceCrowdingConfigOutput) ToSourceCrowdingConfigOutput() SourceCrowdingConfigOutput {
	return o
}

func (o SourceCrowdingConfigOutput) ToSourceCrowdingConfigOutputWithContext(ctx context.Context) SourceCrowdingConfigOutput {
	return o
}

func (o SourceCrowdingConfigOutput) ToSourceCrowdingConfigPtrOutput() SourceCrowdingConfigPtrOutput {
	return o.ToSourceCrowdingConfigPtrOutputWithContext(context.Background())
}

func (o SourceCrowdingConfigOutput) ToSourceCrowdingConfigPtrOutputWithContext(ctx context.Context) SourceCrowdingConfigPtrOutput {
	return o.ApplyT(func(v SourceCrowdingConfig) *SourceCrowdingConfig {
		return &v
	}).(SourceCrowdingConfigPtrOutput)
}

// Maximum number of results allowed from a source. No limits will be set on results if this value is less than or equal to 0.
func (o SourceCrowdingConfigOutput) NumResults() pulumi.IntPtrOutput {
	return o.ApplyT(func(v SourceCrowdingConfig) *int { return v.NumResults }).(pulumi.IntPtrOutput)
}

// Maximum number of suggestions allowed from a source. No limits will be set on results if this value is less than or equal to 0.
func (o SourceCrowdingConfigOutput) NumSuggestions() pulumi.IntPtrOutput {
	return o.ApplyT(func(v SourceCrowdingConfig) *int { return v.NumSuggestions }).(pulumi.IntPtrOutput)
}

type SourceCrowdingConfigPtrOutput struct{ *pulumi.OutputState }

func (SourceCrowdingConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SourceCrowdingConfig)(nil)).Elem()
}

func (o SourceCrowdingConfigPtrOutput) ToSourceCrowdingConfigPtrOutput() SourceCrowdingConfigPtrOutput {
	return o
}

func (o SourceCrowdingConfigPtrOutput) ToSourceCrowdingConfigPtrOutputWithContext(ctx context.Context) SourceCrowdingConfigPtrOutput {
	return o
}

func (o SourceCrowdingConfigPtrOutput) Elem() SourceCrowdingConfigOutput {
	return o.ApplyT(func(v *SourceCrowdingConfig) SourceCrowdingConfig { return *v }).(SourceCrowdingConfigOutput)
}

// Maximum number of results allowed from a source. No limits will be set on results if this value is less than or equal to 0.
func (o SourceCrowdingConfigPtrOutput) NumResults() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SourceCrowdingConfig) *int {
		if v == nil {
			return nil
		}
		return v.NumResults
	}).(pulumi.IntPtrOutput)
}

// Maximum number of suggestions allowed from a source. No limits will be set on results if this value is less than or equal to 0.
func (o SourceCrowdingConfigPtrOutput) NumSuggestions() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SourceCrowdingConfig) *int {
		if v == nil {
			return nil
		}
		return v.NumSuggestions
	}).(pulumi.IntPtrOutput)
}

// Set the scoring configuration. This allows modifying the ranking of results for a source.
type SourceScoringConfig struct {
	// Importance of the source.
	SourceImportance *string `pulumi:"sourceImportance"`
}

// SourceScoringConfigInput is an input type that accepts SourceScoringConfigArgs and SourceScoringConfigOutput values.
// You can construct a concrete instance of `SourceScoringConfigInput` via:
//
//          SourceScoringConfigArgs{...}
type SourceScoringConfigInput interface {
	pulumi.Input

	ToSourceScoringConfigOutput() SourceScoringConfigOutput
	ToSourceScoringConfigOutputWithContext(context.Context) SourceScoringConfigOutput
}

// Set the scoring configuration. This allows modifying the ranking of results for a source.
type SourceScoringConfigArgs struct {
	// Importance of the source.
	SourceImportance pulumi.StringPtrInput `pulumi:"sourceImportance"`
}

func (SourceScoringConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SourceScoringConfig)(nil)).Elem()
}

func (i SourceScoringConfigArgs) ToSourceScoringConfigOutput() SourceScoringConfigOutput {
	return i.ToSourceScoringConfigOutputWithContext(context.Background())
}

func (i SourceScoringConfigArgs) ToSourceScoringConfigOutputWithContext(ctx context.Context) SourceScoringConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceScoringConfigOutput)
}

func (i SourceScoringConfigArgs) ToSourceScoringConfigPtrOutput() SourceScoringConfigPtrOutput {
	return i.ToSourceScoringConfigPtrOutputWithContext(context.Background())
}

func (i SourceScoringConfigArgs) ToSourceScoringConfigPtrOutputWithContext(ctx context.Context) SourceScoringConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceScoringConfigOutput).ToSourceScoringConfigPtrOutputWithContext(ctx)
}

// SourceScoringConfigPtrInput is an input type that accepts SourceScoringConfigArgs, SourceScoringConfigPtr and SourceScoringConfigPtrOutput values.
// You can construct a concrete instance of `SourceScoringConfigPtrInput` via:
//
//          SourceScoringConfigArgs{...}
//
//  or:
//
//          nil
type SourceScoringConfigPtrInput interface {
	pulumi.Input

	ToSourceScoringConfigPtrOutput() SourceScoringConfigPtrOutput
	ToSourceScoringConfigPtrOutputWithContext(context.Context) SourceScoringConfigPtrOutput
}

type sourceScoringConfigPtrType SourceScoringConfigArgs

func SourceScoringConfigPtr(v *SourceScoringConfigArgs) SourceScoringConfigPtrInput {
	return (*sourceScoringConfigPtrType)(v)
}

func (*sourceScoringConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SourceScoringConfig)(nil)).Elem()
}

func (i *sourceScoringConfigPtrType) ToSourceScoringConfigPtrOutput() SourceScoringConfigPtrOutput {
	return i.ToSourceScoringConfigPtrOutputWithContext(context.Background())
}

func (i *sourceScoringConfigPtrType) ToSourceScoringConfigPtrOutputWithContext(ctx context.Context) SourceScoringConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceScoringConfigPtrOutput)
}

// Set the scoring configuration. This allows modifying the ranking of results for a source.
type SourceScoringConfigOutput struct{ *pulumi.OutputState }

func (SourceScoringConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SourceScoringConfig)(nil)).Elem()
}

func (o SourceScoringConfigOutput) ToSourceScoringConfigOutput() SourceScoringConfigOutput {
	return o
}

func (o SourceScoringConfigOutput) ToSourceScoringConfigOutputWithContext(ctx context.Context) SourceScoringConfigOutput {
	return o
}

func (o SourceScoringConfigOutput) ToSourceScoringConfigPtrOutput() SourceScoringConfigPtrOutput {
	return o.ToSourceScoringConfigPtrOutputWithContext(context.Background())
}

func (o SourceScoringConfigOutput) ToSourceScoringConfigPtrOutputWithContext(ctx context.Context) SourceScoringConfigPtrOutput {
	return o.ApplyT(func(v SourceScoringConfig) *SourceScoringConfig {
		return &v
	}).(SourceScoringConfigPtrOutput)
}

// Importance of the source.
func (o SourceScoringConfigOutput) SourceImportance() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SourceScoringConfig) *string { return v.SourceImportance }).(pulumi.StringPtrOutput)
}

type SourceScoringConfigPtrOutput struct{ *pulumi.OutputState }

func (SourceScoringConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SourceScoringConfig)(nil)).Elem()
}

func (o SourceScoringConfigPtrOutput) ToSourceScoringConfigPtrOutput() SourceScoringConfigPtrOutput {
	return o
}

func (o SourceScoringConfigPtrOutput) ToSourceScoringConfigPtrOutputWithContext(ctx context.Context) SourceScoringConfigPtrOutput {
	return o
}

func (o SourceScoringConfigPtrOutput) Elem() SourceScoringConfigOutput {
	return o.ApplyT(func(v *SourceScoringConfig) SourceScoringConfig { return *v }).(SourceScoringConfigOutput)
}

// Importance of the source.
func (o SourceScoringConfigPtrOutput) SourceImportance() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SourceScoringConfig) *string {
		if v == nil {
			return nil
		}
		return v.SourceImportance
	}).(pulumi.StringPtrOutput)
}

// Definition of a single value with generic type.
type Value struct {
	BooleanValue   *bool    `pulumi:"booleanValue"`
	DateValue      *Date    `pulumi:"dateValue"`
	DoubleValue    *float64 `pulumi:"doubleValue"`
	IntegerValue   *string  `pulumi:"integerValue"`
	StringValue    *string  `pulumi:"stringValue"`
	TimestampValue *string  `pulumi:"timestampValue"`
}

// ValueInput is an input type that accepts ValueArgs and ValueOutput values.
// You can construct a concrete instance of `ValueInput` via:
//
//          ValueArgs{...}
type ValueInput interface {
	pulumi.Input

	ToValueOutput() ValueOutput
	ToValueOutputWithContext(context.Context) ValueOutput
}

// Definition of a single value with generic type.
type ValueArgs struct {
	BooleanValue   pulumi.BoolPtrInput    `pulumi:"booleanValue"`
	DateValue      DatePtrInput           `pulumi:"dateValue"`
	DoubleValue    pulumi.Float64PtrInput `pulumi:"doubleValue"`
	IntegerValue   pulumi.StringPtrInput  `pulumi:"integerValue"`
	StringValue    pulumi.StringPtrInput  `pulumi:"stringValue"`
	TimestampValue pulumi.StringPtrInput  `pulumi:"timestampValue"`
}

func (ValueArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Value)(nil)).Elem()
}

func (i ValueArgs) ToValueOutput() ValueOutput {
	return i.ToValueOutputWithContext(context.Background())
}

func (i ValueArgs) ToValueOutputWithContext(ctx context.Context) ValueOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ValueOutput)
}

func (i ValueArgs) ToValuePtrOutput() ValuePtrOutput {
	return i.ToValuePtrOutputWithContext(context.Background())
}

func (i ValueArgs) ToValuePtrOutputWithContext(ctx context.Context) ValuePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ValueOutput).ToValuePtrOutputWithContext(ctx)
}

// ValuePtrInput is an input type that accepts ValueArgs, ValuePtr and ValuePtrOutput values.
// You can construct a concrete instance of `ValuePtrInput` via:
//
//          ValueArgs{...}
//
//  or:
//
//          nil
type ValuePtrInput interface {
	pulumi.Input

	ToValuePtrOutput() ValuePtrOutput
	ToValuePtrOutputWithContext(context.Context) ValuePtrOutput
}

type valuePtrType ValueArgs

func ValuePtr(v *ValueArgs) ValuePtrInput {
	return (*valuePtrType)(v)
}

func (*valuePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Value)(nil)).Elem()
}

func (i *valuePtrType) ToValuePtrOutput() ValuePtrOutput {
	return i.ToValuePtrOutputWithContext(context.Background())
}

func (i *valuePtrType) ToValuePtrOutputWithContext(ctx context.Context) ValuePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ValuePtrOutput)
}

// Definition of a single value with generic type.
type ValueOutput struct{ *pulumi.OutputState }

func (ValueOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Value)(nil)).Elem()
}

func (o ValueOutput) ToValueOutput() ValueOutput {
	return o
}

func (o ValueOutput) ToValueOutputWithContext(ctx context.Context) ValueOutput {
	return o
}

func (o ValueOutput) ToValuePtrOutput() ValuePtrOutput {
	return o.ToValuePtrOutputWithContext(context.Background())
}

func (o ValueOutput) ToValuePtrOutputWithContext(ctx context.Context) ValuePtrOutput {
	return o.ApplyT(func(v Value) *Value {
		return &v
	}).(ValuePtrOutput)
}
func (o ValueOutput) BooleanValue() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Value) *bool { return v.BooleanValue }).(pulumi.BoolPtrOutput)
}

func (o ValueOutput) DateValue() DatePtrOutput {
	return o.ApplyT(func(v Value) *Date { return v.DateValue }).(DatePtrOutput)
}

func (o ValueOutput) DoubleValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Value) *float64 { return v.DoubleValue }).(pulumi.Float64PtrOutput)
}

func (o ValueOutput) IntegerValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Value) *string { return v.IntegerValue }).(pulumi.StringPtrOutput)
}

func (o ValueOutput) StringValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Value) *string { return v.StringValue }).(pulumi.StringPtrOutput)
}

func (o ValueOutput) TimestampValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Value) *string { return v.TimestampValue }).(pulumi.StringPtrOutput)
}

type ValuePtrOutput struct{ *pulumi.OutputState }

func (ValuePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Value)(nil)).Elem()
}

func (o ValuePtrOutput) ToValuePtrOutput() ValuePtrOutput {
	return o
}

func (o ValuePtrOutput) ToValuePtrOutputWithContext(ctx context.Context) ValuePtrOutput {
	return o
}

func (o ValuePtrOutput) Elem() ValueOutput {
	return o.ApplyT(func(v *Value) Value { return *v }).(ValueOutput)
}

func (o ValuePtrOutput) BooleanValue() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Value) *bool {
		if v == nil {
			return nil
		}
		return v.BooleanValue
	}).(pulumi.BoolPtrOutput)
}

func (o ValuePtrOutput) DateValue() DatePtrOutput {
	return o.ApplyT(func(v *Value) *Date {
		if v == nil {
			return nil
		}
		return v.DateValue
	}).(DatePtrOutput)
}

func (o ValuePtrOutput) DoubleValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Value) *float64 {
		if v == nil {
			return nil
		}
		return v.DoubleValue
	}).(pulumi.Float64PtrOutput)
}

func (o ValuePtrOutput) IntegerValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Value) *string {
		if v == nil {
			return nil
		}
		return v.IntegerValue
	}).(pulumi.StringPtrOutput)
}

func (o ValuePtrOutput) StringValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Value) *string {
		if v == nil {
			return nil
		}
		return v.StringValue
	}).(pulumi.StringPtrOutput)
}

func (o ValuePtrOutput) TimestampValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Value) *string {
		if v == nil {
			return nil
		}
		return v.TimestampValue
	}).(pulumi.StringPtrOutput)
}

type ValueFilter struct {
	// The `operator_name` applied to the query, such as *price_greater_than*. The filter can work against both types of filters defined in the schema for your data source: 1. `operator_name`, where the query filters results by the property that matches the value. 2. `greater_than_operator_name` or `less_than_operator_name` in your schema. The query filters the results for the property values that are greater than or less than the supplied value in the query.
	OperatorName *string `pulumi:"operatorName"`
	// The value to be compared with.
	Value *Value `pulumi:"value"`
}

// ValueFilterInput is an input type that accepts ValueFilterArgs and ValueFilterOutput values.
// You can construct a concrete instance of `ValueFilterInput` via:
//
//          ValueFilterArgs{...}
type ValueFilterInput interface {
	pulumi.Input

	ToValueFilterOutput() ValueFilterOutput
	ToValueFilterOutputWithContext(context.Context) ValueFilterOutput
}

type ValueFilterArgs struct {
	// The `operator_name` applied to the query, such as *price_greater_than*. The filter can work against both types of filters defined in the schema for your data source: 1. `operator_name`, where the query filters results by the property that matches the value. 2. `greater_than_operator_name` or `less_than_operator_name` in your schema. The query filters the results for the property values that are greater than or less than the supplied value in the query.
	OperatorName pulumi.StringPtrInput `pulumi:"operatorName"`
	// The value to be compared with.
	Value ValuePtrInput `pulumi:"value"`
}

func (ValueFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ValueFilter)(nil)).Elem()
}

func (i ValueFilterArgs) ToValueFilterOutput() ValueFilterOutput {
	return i.ToValueFilterOutputWithContext(context.Background())
}

func (i ValueFilterArgs) ToValueFilterOutputWithContext(ctx context.Context) ValueFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ValueFilterOutput)
}

func (i ValueFilterArgs) ToValueFilterPtrOutput() ValueFilterPtrOutput {
	return i.ToValueFilterPtrOutputWithContext(context.Background())
}

func (i ValueFilterArgs) ToValueFilterPtrOutputWithContext(ctx context.Context) ValueFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ValueFilterOutput).ToValueFilterPtrOutputWithContext(ctx)
}

// ValueFilterPtrInput is an input type that accepts ValueFilterArgs, ValueFilterPtr and ValueFilterPtrOutput values.
// You can construct a concrete instance of `ValueFilterPtrInput` via:
//
//          ValueFilterArgs{...}
//
//  or:
//
//          nil
type ValueFilterPtrInput interface {
	pulumi.Input

	ToValueFilterPtrOutput() ValueFilterPtrOutput
	ToValueFilterPtrOutputWithContext(context.Context) ValueFilterPtrOutput
}

type valueFilterPtrType ValueFilterArgs

func ValueFilterPtr(v *ValueFilterArgs) ValueFilterPtrInput {
	return (*valueFilterPtrType)(v)
}

func (*valueFilterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ValueFilter)(nil)).Elem()
}

func (i *valueFilterPtrType) ToValueFilterPtrOutput() ValueFilterPtrOutput {
	return i.ToValueFilterPtrOutputWithContext(context.Background())
}

func (i *valueFilterPtrType) ToValueFilterPtrOutputWithContext(ctx context.Context) ValueFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ValueFilterPtrOutput)
}

type ValueFilterOutput struct{ *pulumi.OutputState }

func (ValueFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ValueFilter)(nil)).Elem()
}

func (o ValueFilterOutput) ToValueFilterOutput() ValueFilterOutput {
	return o
}

func (o ValueFilterOutput) ToValueFilterOutputWithContext(ctx context.Context) ValueFilterOutput {
	return o
}

func (o ValueFilterOutput) ToValueFilterPtrOutput() ValueFilterPtrOutput {
	return o.ToValueFilterPtrOutputWithContext(context.Background())
}

func (o ValueFilterOutput) ToValueFilterPtrOutputWithContext(ctx context.Context) ValueFilterPtrOutput {
	return o.ApplyT(func(v ValueFilter) *ValueFilter {
		return &v
	}).(ValueFilterPtrOutput)
}

// The `operator_name` applied to the query, such as *price_greater_than*. The filter can work against both types of filters defined in the schema for your data source: 1. `operator_name`, where the query filters results by the property that matches the value. 2. `greater_than_operator_name` or `less_than_operator_name` in your schema. The query filters the results for the property values that are greater than or less than the supplied value in the query.
func (o ValueFilterOutput) OperatorName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ValueFilter) *string { return v.OperatorName }).(pulumi.StringPtrOutput)
}

// The value to be compared with.
func (o ValueFilterOutput) Value() ValuePtrOutput {
	return o.ApplyT(func(v ValueFilter) *Value { return v.Value }).(ValuePtrOutput)
}

type ValueFilterPtrOutput struct{ *pulumi.OutputState }

func (ValueFilterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ValueFilter)(nil)).Elem()
}

func (o ValueFilterPtrOutput) ToValueFilterPtrOutput() ValueFilterPtrOutput {
	return o
}

func (o ValueFilterPtrOutput) ToValueFilterPtrOutputWithContext(ctx context.Context) ValueFilterPtrOutput {
	return o
}

func (o ValueFilterPtrOutput) Elem() ValueFilterOutput {
	return o.ApplyT(func(v *ValueFilter) ValueFilter { return *v }).(ValueFilterOutput)
}

// The `operator_name` applied to the query, such as *price_greater_than*. The filter can work against both types of filters defined in the schema for your data source: 1. `operator_name`, where the query filters results by the property that matches the value. 2. `greater_than_operator_name` or `less_than_operator_name` in your schema. The query filters the results for the property values that are greater than or less than the supplied value in the query.
func (o ValueFilterPtrOutput) OperatorName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ValueFilter) *string {
		if v == nil {
			return nil
		}
		return v.OperatorName
	}).(pulumi.StringPtrOutput)
}

// The value to be compared with.
func (o ValueFilterPtrOutput) Value() ValuePtrOutput {
	return o.ApplyT(func(v *ValueFilter) *Value {
		if v == nil {
			return nil
		}
		return v.Value
	}).(ValuePtrOutput)
}

func init() {
	pulumi.RegisterOutputType(CompositeFilterOutput{})
	pulumi.RegisterOutputType(CompositeFilterPtrOutput{})
	pulumi.RegisterOutputType(DataSourceRestrictionOutput{})
	pulumi.RegisterOutputType(DataSourceRestrictionArrayOutput{})
	pulumi.RegisterOutputType(DateOutput{})
	pulumi.RegisterOutputType(DatePtrOutput{})
	pulumi.RegisterOutputType(FacetOptionsOutput{})
	pulumi.RegisterOutputType(FacetOptionsArrayOutput{})
	pulumi.RegisterOutputType(FilterOutput{})
	pulumi.RegisterOutputType(FilterPtrOutput{})
	pulumi.RegisterOutputType(FilterArrayOutput{})
	pulumi.RegisterOutputType(FilterOptionsOutput{})
	pulumi.RegisterOutputType(FilterOptionsArrayOutput{})
	pulumi.RegisterOutputType(GSuitePrincipalOutput{})
	pulumi.RegisterOutputType(GSuitePrincipalArrayOutput{})
	pulumi.RegisterOutputType(ScoringConfigOutput{})
	pulumi.RegisterOutputType(ScoringConfigPtrOutput{})
	pulumi.RegisterOutputType(SortOptionsOutput{})
	pulumi.RegisterOutputType(SortOptionsPtrOutput{})
	pulumi.RegisterOutputType(SourceOutput{})
	pulumi.RegisterOutputType(SourcePtrOutput{})
	pulumi.RegisterOutputType(SourceConfigOutput{})
	pulumi.RegisterOutputType(SourceConfigArrayOutput{})
	pulumi.RegisterOutputType(SourceCrowdingConfigOutput{})
	pulumi.RegisterOutputType(SourceCrowdingConfigPtrOutput{})
	pulumi.RegisterOutputType(SourceScoringConfigOutput{})
	pulumi.RegisterOutputType(SourceScoringConfigPtrOutput{})
	pulumi.RegisterOutputType(ValueOutput{})
	pulumi.RegisterOutputType(ValuePtrOutput{})
	pulumi.RegisterOutputType(ValueFilterOutput{})
	pulumi.RegisterOutputType(ValueFilterPtrOutput{})
}
